/* 
	MFBlacklist.cpp

	Author:			ch
	Description:	<describe the MFBlacklist class here>
*/

#define _MFD_MODULE MSG("MFBlacklist.cpp", 1)
#include "MFBlacklist.h"
#ifdef __NOVELL_LIBC__
#include <arpa/inet.h>
#include <netinet/in.h>
#endif

#ifdef NETDB_DEFINE_CONTEXT 
NETDB_DEFINE_CONTEXT 
#endif

MFBlacklist::MFBlacklist(char* holeZone)
{
	this->m_holeZone = _mfd_strdup(holeZone,MSG("new MFBlacklist", 2));
}

MFBlacklist::~MFBlacklist()
{
	if (!this->m_holeZone)
		return;
	
	_mfd_free(this->m_holeZone,MSG("~MFBlacklist", 3));
	
}

int MFBlacklist::LookupIpAsync(char* host)
{
	return this->Lookup(host);
}

int MFBlacklist::Lookup(char* host)
{
	struct hostent* he;
	struct in_addr ad;
	int rc = 0;
	char* fullHost = (char*)_mfd_malloc(MAX_PATH,MSG("LookupAsync", 4));

#ifdef snprintf
		snprintf(fullHost,MAX_PATH,
#else
		sprintf(fullHost,
#endif
		MSG("%s.%s", 5),host,this->m_holeZone);

#ifdef inet_aton
	if (inet_aton (host, &ad))
	{
#else
	long addr = (long)inet_addr(host);
	if (addr != (-1))
	{
		ad.S_un.S_addr = (unsigned long)addr;
#endif
		MFD_Out(MFD_SOURCE_SMTP,MSG("made %d.%d.%d.%d\n", 6),
				ad.S_un.S_un_b.s_b1,
				ad.S_un.S_un_b.s_b2,
				ad.S_un.S_un_b.s_b3,
				ad.S_un.S_un_b.s_b4);
		/* rbl wants it reverse */
#ifdef snprintf
		snprintf(fullHost,MAX_PATH,
#else
		sprintf(fullHost,
#endif
				MSG("%d.%d.%d.%d.%s", 7),
				ad.S_un.S_un_b.s_b4,
				ad.S_un.S_un_b.s_b3,
				ad.S_un.S_un_b.s_b2,
				ad.S_un.S_un_b.s_b1,
			this->m_holeZone);
	} else 
		{
		MFD_Out(MFD_SOURCE_SMTP,MSG("Blacklist: gethostbyname(%s)\n", 8),host);
		he = gethostbyname(host);
		if (!he)
		{
			MFD_Out(MFD_SOURCE_SMTP,MSG("Blackhole check failed [no ip, no host] for '%s'\n", 9),host);
			_mfd_free(fullHost,MSG("LookupAsync|fullHost", 10));
			return 0;
		} else {
			if (he->h_addr_list)
			{
				memcpy(&ad.S_un.S_addr,he->h_addr_list[0],he->h_length);
#ifdef __NOVELL_LIBC__
				snprintf(fullHost,MAX_PATH,
#else
				sprintf(fullHost,
#endif
					MSG("%d.%d.%d.%d.%s", 11),
					ad.S_un.S_un_b.s_b4,
					ad.S_un.S_un_b.s_b3,
					ad.S_un.S_un_b.s_b2,
					ad.S_un.S_un_b.s_b1,
					this->m_holeZone);
				
			}
				else
				{
					MFD_Out(MFD_SOURCE_SMTP,MSG("Blackhole check failed [no ip from host] for '%s'\n", 12),host);
					_mfd_free(fullHost,MSG("LookupAsync|fullHost", 13));
					return 0;
				}
		}
	}
	
	MFD_Out(MFD_SOURCE_SMTP,MSG("Blackhole check for %s\n", 14),fullHost);
	he = gethostbyname(fullHost);
	if (!he)
	{	
		MFD_Out(MFD_SOURCE_SMTP,MSG("Blacklist result: %d\n", 15),h_errno);
		rc = 0;
	} else {
	
		MFD_Out(MFD_SOURCE_SMTP,MSG("Blacklist entry found for %s\n", 16),host);
		rc = 1;
	}

	_mfd_free(fullHost,MSG("LookupIpAsync", 17));
	
	return rc;
}

