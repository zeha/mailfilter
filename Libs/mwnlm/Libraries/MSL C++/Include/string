/* Metrowerks Standard Library
 * Copyright © 1995-2002 Metrowerks Corporation.  All rights reserved.
 *
 * $Date: 2002/08/09 22:31:13 $ 
 * $Revision: 1.4 $ 
 */
 
// string

#ifndef _STRING
#define _STRING

/*  string synopsis

namespace std
{

template <class stateT>
class fpos
{
public:
	fpos(streamoff o);
	operator streamoff() const;
	fpos& operator += (streamoff o);
	fpos& operator -= (streamoff o);
	fpos operator + (streamoff o) const;
	fpos operator - (streamoff o) const;
	// _lib.fpos.members_ Members
	stateT state() const;
	void state(stateT s);
};

template <class stateT>
streamoff
operator - (const fpos<stateT>& lhs, const fpos<stateT>& rhs);

template<class charT>
struct char_traits
{
	typedef charT       char_type;
	typedef int         int_type;
	typedef streamoff   off_type;
	typedef streampos   pos_type;
	typedef mbstate_t   state_type;

	static void assign(char_type& c1, const char_type& c2);
	static bool eq(const char_type& c1, const char_type& c2);
	static bool lt(const char_type& c1, const char_type& c2);

	static int compare(const char_type* s1, const char_type* s2, size_t n);
	static size_t length(const char_type* s);
	static const char_type* find(const char_type* s, size_t n, const char_type& a);
	static char_type* move(char_type* s1, const char_type* s2, size_t n);
	static char_type* copy(char_type* s1, const char_type* s2, size_t n);
	static char_type* assign(char_type* s, size_t n, char_type a);

	static int_type not_eof(const int_type& c);
	static char_type to_char_type(const int_type& c);
	static int_type to_int_type(const char_type& c);
	static bool eq_int_type(const int_type& c1, const int_type& c2);
	static int_type eof();
};

template<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >
class basic_string
{
public:
	//  types:
	typedef          traits                     traits_type;
	typedef typename traits::char_type          value_type;
	typedef          Allocator                  allocator_type;
	typedef typename Allocator::size_type       size_type;
	typedef typename Allocator::difference_type difference_type;
	typedef typename Allocator::reference       reference;
	typedef typename Allocator::const_reference const_reference;
	typedef typename Allocator::pointer         pointer;
	typedef typename Allocator::const_pointer   const_pointer;

	class                                       iterator;       //  random access
	class                                       const_iterator; //  random access
	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	static const size_type npos = -1;

	//  lib.string.cons construct/copy/destroy:
	explicit basic_string(const Allocator& a = Allocator());
	basic_string(const basic_string& str, size_type pos = 0, size_type n = npos,
	             const Allocator& a = Allocator());
	basic_string(const charT* s, size_type n, const Allocator& a = Allocator());
	basic_string(const charT* s, const Allocator& a = Allocator());
	basic_string(size_type n, charT c, const Allocator& a = Allocator());
	template<class InputIterator>
		basic_string(InputIterator begin, InputIterator end, const Allocator& a = Allocator());
	~basic_string();
	basic_string& operator=(const basic_string& str);
	basic_string& operator=(const charT* s);
	basic_string& operator=(charT c);

	//  lib.string.iterators iterators:
	iterator       begin();
	const_iterator begin() const;
	iterator       end();
	const_iterator end() const;

	reverse_iterator       rbegin();
	const_reverse_iterator rbegin() const;
	reverse_iterator       rend();
	const_reverse_iterator rend() const;

	//  lib.string.capacity capacity:
	size_type size() const;
	size_type length() const;
	size_type max_size() const;
	void resize(size_type n, charT c);
	void resize(size_type n);
	size_type capacity() const;
	void reserve(size_type res_arg = 0);
	void clear();
	bool empty() const;

	//  lib.string.access element access:
	const_reference operator[](size_type pos) const;
	reference       operator[](size_type pos);
	const_reference at(size_type n) const;
	reference       at(size_type n);

	//  lib.string.modifiers modifiers:
	basic_string& operator+=(const basic_string& str);
	basic_string& operator+=(const charT* s);
	basic_string& operator+=(charT c);
	basic_string& append(const basic_string& str);
	basic_string& append(const basic_string& str, size_type pos, size_type n);
	basic_string& append(const charT* s, size_type n);
	basic_string& append(const charT* s);
	basic_string& append(size_type n, charT c);
	template<class InputIterator>
		basic_string& append(InputIterator first, InputIterator last);
	void push_back(const charT);
	void pop_back();             // Metrowerks extension

	basic_string& assign(const basic_string&);
	basic_string& assign(const basic_string& str, size_type pos, size_type n);
	basic_string& assign(const charT* s, size_type n);
	basic_string& assign(const charT* s);
	basic_string& assign(size_type n, charT c);
	template<class InputIterator>
		basic_string& assign(InputIterator first, InputIterator last);

	basic_string& insert(size_type pos1, const basic_string& str);
	basic_string& insert(size_type pos1, const basic_string& str, size_type pos2, size_type n);
	basic_string& insert(size_type pos, const charT* s, size_type n);
	basic_string& insert(size_type pos, const charT* s);
	basic_string& insert(size_type pos, size_type n, charT c);
	iterator      insert(iterator p, charT c);
	void          insert(iterator p, size_type n, charT c);
	template<class InputIterator>
		void      insert(iterator p, InputIterator first, InputIterator last);

	basic_string& erase(size_type pos = 0, size_type n = npos);
	iterator      erase(iterator position);
	iterator      erase(iterator first, iterator last);

	basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
	basic_string& replace(size_type pos1, size_type n1, const basic_string& str, size_type pos2, size_type n2);
	basic_string& replace(size_type pos, size_type n1, const charT* s, size_type n2);
	basic_string& replace(size_type pos, size_type n1, const charT* s);
	basic_string& replace(size_type pos, size_type n1, size_type n2, charT c);
	basic_string& replace(iterator i1, iterator i2, const basic_string& str);
	basic_string& replace(iterator i1, iterator i2, const charT* s, size_type n);
	basic_string& replace(iterator i1, iterator i2, const charT* s);
	basic_string& replace(iterator i1, iterator i2, size_type n, charT c);
	template<class InputIterator>
	basic_string& replace(iterator i1, iterator i2, InputIterator j1, InputIterator j2);

	size_type copy(charT* s, size_type n, size_type pos = 0) const;
	void swap(basic_string<charT,traits,Allocator>&);

	//  lib.string.ops string operations:
	const charT* c_str() const;         //  explicit
	const charT* data() const;
	allocator_type get_allocator() const;

	size_type find (const basic_string& str, size_type pos = 0) const;
	size_type find (const charT* s, size_type pos, size_type n) const;
	size_type find (const charT* s, size_type pos = 0) const;
	size_type find (charT c, size_type pos = 0) const;
	size_type rfind(const basic_string& str, size_type pos = npos) const;
	size_type rfind(const charT* s, size_type pos, size_type n) const;
	size_type rfind(const charT* s, size_type pos = npos) const;
	size_type rfind(charT c, size_type pos = npos) const;

	size_type find_first_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_of(const charT* s,	size_type pos, size_type n) const;
	size_type find_first_of(const charT* s, size_type pos = 0) const;
	size_type find_first_of(charT c, size_type pos = 0) const;

	size_type find_last_of(const basic_string& str, size_type pos = npos) const;
	size_type find_last_of(const charT* s, size_type pos, size_type n) const;
	size_type find_last_of(const charT* s, size_type pos = npos) const;
	size_type find_last_of(charT c, size_type pos = npos) const;

	size_type find_first_not_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
	size_type find_first_not_of(const charT* s, size_type pos = 0) const;
	size_type find_first_not_of(charT c, size_type pos = 0) const;

	size_type find_last_not_of (const basic_string& str, size_type pos = npos) const;
	size_type find_last_not_of (const charT* s, size_type pos, size_type n) const;
	size_type find_last_not_of (const charT* s, size_type pos = npos) const;
	size_type find_last_not_of (charT c, size_type pos = npos) const;

	basic_string substr(size_type pos = 0, size_type n = npos) const;

	int compare(const basic_string& str) const;
	int compare(size_type pos1, size_type n1, const basic_string& str) const;
	int compare(size_type pos1, size_type n1, const basic_string& str, size_type pos2, size_type n2) const;
	int compare(const charT* s) const;
	int compare(size_type pos1, size_type n1, const charT* s) const;
	int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;
};

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);

template<class charT, class traits, class Allocator>
bool
operator==(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator==(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator!=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator!=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator!=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator< (const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator< (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator< (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator> (const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator> (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator> (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator<=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator<=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator<=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator>=(const basic_string<charT,traits,Allocator>& lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator>=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator>=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
void
swap(basic_string<charT,traits,Allocator>& lhs, basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
operator>>(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str, charT  delim);

template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str);

typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;

}  // std
*/

#include <mslconfig>
#ifndef _MSL_NO_WCHART_C_SUPPORT
	#include <cwchar>
#else
	#include <cstdio>
#endif
#include <cstring>
#include <iosfwd>
#include <memory>
#include <stdexcept>
#include <iterator>
#include <algorithm>
#include <limits>
#ifndef _MSL_NO_REFCOUNT_STRING
	#include <msl_mutex>
#endif

#ifndef RC_INVOKED

#pragma options align=native

#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT
	#if _MSL_FORCE_ENUMS_ALWAYS_INT
		#pragma enumsalwaysint on
	#else
		#pragma enumsalwaysint off
	#endif
#endif

#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT
	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT
		#pragma bool on
	#else
		#pragma bool off
	#endif
#endif

#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
	namespace std {
#endif

// fpos

template <class stateT>
class fpos
{
public:
	fpos(streamoff o);
	operator streamoff() const;
	fpos& operator += (streamoff o);
	fpos& operator -= (streamoff o);
	fpos operator + (streamoff o) const;
	fpos operator - (streamoff o) const;
	// _lib.fpos.members_ Members
	stateT state() const;
	void state(stateT s);
private:
	streamoff offset_;
	stateT st_;
};

template <class stateT>
inline
fpos<stateT>::fpos(streamoff o)
	: offset_(o),
	  st_(stateT())
{
}

template <class stateT>
inline
fpos<stateT>::operator streamoff() const
{
	return offset_;
}

template <class stateT>
inline
fpos<stateT>&
fpos<stateT>::operator += (streamoff o)
{
	offset_ += o;
	return *this;
}

template <class stateT>
inline
fpos<stateT>&
fpos<stateT>::operator -= (streamoff o)
{
	offset_ -= o;
	return *this;
}

template <class stateT>
inline
fpos<stateT>
fpos<stateT>::operator + (streamoff o) const
{
	return fpos<stateT>(offset_ + o);
}

template <class stateT>
inline
fpos<stateT>
fpos<stateT>::operator - (streamoff o) const
{
	return fpos<stateT>(offset_ - o);
}

template <class stateT>
inline
stateT
fpos<stateT>::state() const
{
	return st_;
}

template <class stateT>
inline
void
fpos<stateT>::state(stateT s)
{
	st_ = s;
}

template <class stateT>
inline
streamoff
operator - (const fpos<stateT>& lhs, const fpos<stateT>& rhs)
{
	return streamoff(lhs) - streamoff(rhs);
}

// _lib.char.traits_, character traits:

template<class charT>
struct char_traits
{
	typedef charT       char_type;
	typedef int         int_type;
	typedef streamoff   off_type;
	typedef streampos   pos_type;
	typedef mbstate_t   state_type;

	static void assign(char_type& c1, const char_type& c2);
	static bool eq(const char_type& c1, const char_type& c2);
	static bool lt(const char_type& c1, const char_type& c2);

	static int compare(const char_type* s1, const char_type* s2, size_t n);
	static size_t length(const char_type* s);
	static const char_type* find(const char_type* s, size_t n, const char_type& a);
	static char_type* move(char_type* s1, const char_type* s2, size_t n);
	static char_type* copy(char_type* s1, const char_type* s2, size_t n);
	static char_type* assign(char_type* s, size_t n, char_type a);

	static int_type not_eof(const int_type& c);
	static char_type to_char_type(const int_type& c);
	static int_type to_int_type(const char_type& c);
	static bool eq_int_type(const int_type& c1, const int_type& c2);
	static int_type eof();
};

// Implementation: char_traits<charT>

template <class charT>
inline
void
char_traits<charT>::assign(char_type& c1, const char_type& c2)
{
	c1 = c2;
}

template <class charT>
inline
bool
char_traits<charT>::eq(const char_type& c1, const char_type& c2)
{
	return c1 == c2;
}

template <class charT>
inline
bool
char_traits<charT>::lt(const char_type& c1, const char_type& c2)
{
	return c1 < c2;
}

template <class charT>
int
char_traits<charT>::compare(const char_type* s1, const char_type* s2, size_t n)
{
	for (size_t i = 0; i < n; ++i, ++s1, ++s2)
	{
		if (lt(*s1, *s2))
			return -1;
		if (lt(*s2, *s1))
			return 1;
	}
	return 0;
}

template <class charT>
size_t
char_traits<charT>::length(const char_type* s)
{
	size_t len = 0;
	while (!eq(*s, charT()))
	{
		++s;
		++len;
	}
	return len;
}

template <class charT>
const typename char_traits<charT>::char_type*
char_traits<charT>::find(const char_type* s, size_t n, const char_type& a)
{
	if (n == 0)
		return 0;
	const char_type* p = s;
	size_t i = 0;
	while (!eq(*p, a))
	{
		++i;
		if (i == n)
			return 0;
		++p;
	}
	return p;
}

template <class charT>
typename char_traits<charT>::char_type*
char_traits<charT>::move(char_type* s1, const char_type* s2, size_t n)
{
	char_type* r = s1;
	if (s1 < s2)
	{
		for (size_t i = 0; i < n; ++i)
			assign(*s1++, *s2++);
	}
	else if (s2 < s1)
	{
		s1 += n;
		s2 += n;
		for (; n > 0; --n)
			assign(*--s1, *--s2);
	}
	return r;
}

template <class charT>
inline
typename char_traits<charT>::char_type*
char_traits<charT>::copy(char_type* s1, const char_type* s2, size_t n)
{
	char_type* r = s1;
	for (size_t i = 0; i < n; ++i)
		assign(*s1++, *s2++);
	return r;
}

template <class charT>
inline
typename char_traits<charT>::char_type*
char_traits<charT>::assign(char_type* s, size_t n, char_type a)
{
	char_type* r = s;
	for (size_t i = 0; i < n; ++i)
		assign(*s++, a);
	return r;
}

template <class charT>
inline
typename char_traits<charT>::int_type
char_traits<charT>::not_eof(const int_type& c)
{
	return eq_int_type(c, eof()) ? ~eof() : c;
}

template <class charT>
inline
typename char_traits<charT>::char_type
char_traits<charT>::to_char_type(const int_type& c)
{
	return charT(c);
}

template <class charT>
inline
typename char_traits<charT>::int_type
char_traits<charT>::to_int_type(const char_type& c)
{
	return int_type(c);
}

template <class charT>
inline
bool
char_traits<charT>::eq_int_type(const int_type& c1, const int_type& c2)
{
	return c1 == c2;
}

template <class charT>
inline
typename char_traits<charT>::int_type
char_traits<charT>::eof()
{
	return EOF;
}

// char_traits<char>

template <>
struct char_traits<char>
{
	typedef char        char_type;
	typedef int         int_type;
	typedef streamoff   off_type;
	typedef streampos   pos_type;
	typedef mbstate_t   state_type;

	static void assign(char_type& c1, const char_type& c2)
		{c1 = c2;}
	static bool eq(const char_type& c1, const char_type& c2)
		{return static_cast<bool>(c1 == c2);}
	static bool lt(const char_type& c1, const char_type& c2)
		{return static_cast<bool>(c1 < c2);}

	static int compare(const char_type* s1, const char_type* s2, size_t n)
		{return memcmp(s1, s2, n);}
	static size_t length(const char_type* s)
		{return strlen(s);}
	static const char_type* find(const char_type* s, size_t n, const char_type& a)
		{return (const char*)memchr(s, to_int_type(a), n);}
	static char_type* move(char_type* s1, const char_type* s2, size_t n)
		{return (char*)memmove(s1, s2, n);}
	static char_type* copy(char_type* s1, const char_type* s2, size_t n)
		{return (char*)memcpy(s1, s2, n);}
	static char_type* assign(char_type* s, size_t n, char_type a)
		{return (char*)memset(s, to_int_type(a), n);}

	static int_type not_eof(const int_type& c)
		{return c == eof() ? ~eof() : c;}
	static char_type to_char_type(const int_type& c)
		{return (char)c;}
	static int_type to_int_type(const char_type& c)
		{return int_type((unsigned char)c);}
	static bool eq_int_type(const int_type& c1, const int_type& c2)
		{return static_cast<bool>(c1 == c2);}
	static int_type eof()
		{return EOF;}
};

#if !defined(_MSL_NO_WCHART_CPP_SUPPORT) && !defined(_MSL_NO_WCHART_C_SUPPORT)

	// char_traits<wchar_t>

	template <>
	struct char_traits<wchar_t>
	{
		typedef wchar_t      char_type;
		typedef wint_t       int_type;
		typedef streamoff    off_type;
		typedef wstreampos   pos_type;
		typedef mbstate_t    state_type;

		static void assign(char_type& c1, const char_type& c2)
			{c1 = c2;}
		static bool eq(const char_type& c1, const char_type& c2)
			{return c1 == c2;}
		static bool lt(const char_type& c1, const char_type& c2)
			{return c1 < c2;}

		static int compare(const char_type* s1, const char_type* s2, size_t n)
			{return wmemcmp(s1, s2, n);}
		static size_t length(const char_type* s)
			{return wcslen(s);}
		static const char_type* find(const char_type* s, size_t n, const char_type& a)
			{return (const wchar_t*)wmemchr(s, a, n);}
		static char_type* move(char_type* s1, const char_type* s2, size_t n)
			{return (wchar_t*)wmemmove(s1, s2, n);}
		static char_type* copy(char_type* s1, const char_type* s2, size_t n)
			{return (wchar_t*)wmemcpy(s1, s2, n);}
		static char_type* assign(char_type* s, size_t n, char_type a)
			{return (wchar_t*)wmemset(s, a, n);}

		static int_type not_eof(const int_type& c)
			{return int_type(c == eof() ? ~eof() : c);}
		static char_type to_char_type(const int_type& c)
			{return (wchar_t)c;}
		static int_type to_int_type(const char_type& c)
			{return c;}
		static bool eq_int_type(const int_type& c1, const int_type& c2)
			{return c1 == c2;}
		static int_type eof()
			{return WEOF;}
	};

#endif // !defined(_MSL_NO_WCHART_CPP_SUPPORT) && !defined(_MSL_NO_WCHART_C_SUPPORT)

// _lib.basic.string_, basic_string:

template<class charT, class traits = char_traits<charT>,
         class Allocator = allocator<charT> >
class basic_string
{
#ifndef _MSL_NO_REFCOUNT_STRING
	class CharArray;
#endif
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template <bool b> struct chooser {};
	#endif
#ifndef _MSL_NO_REFCOUNT_STRING
	typedef _MSL_REBIND(CharArray)               CharArray_allocator;
#endif
public:
	// types:
	typedef          traits                     traits_type;
	typedef typename traits::char_type          value_type;
	typedef          Allocator                  allocator_type;
	typedef typename Allocator::size_type       size_type;
	typedef typename Allocator::difference_type difference_type;
	typedef typename Allocator::reference       reference;
	typedef typename Allocator::const_reference const_reference;
	typedef typename Allocator::pointer         pointer;
	typedef typename Allocator::const_pointer   const_pointer;

#ifdef _MSL_DEBUG
	typedef pointer                                __uncheck_iterator;
	typedef const_pointer                          __uncheck_const_iterator;
	typedef __debug_iterator<basic_string, __uncheck_iterator>        iterator;
	typedef __debug_iterator<basic_string, __uncheck_const_iterator>  const_iterator;
private:
	pointer __iterator2pointer(const iterator& i)
		{
			if (i.owner_ != this)
				_MSL_ERROR(logic_error, "MSL DEBUG: invalid iterator given to basic_string");
			return i.base();
		}
	const_pointer __iterator2pointer(const const_iterator& i) const
		{
			if (i.owner_ != this)
				_MSL_ERROR(logic_error, "MSL DEBUG: invalid iterator given to basic_string");
			return i.base();
		}
	iterator              __pointer2iterator(const pointer& p)             {return iterator(this, p);}
	const_iterator        __pointer2iterator(const const_pointer& p) const {return const_iterator(this, p);}
public:
#elif defined(_MSL_RAW_ITERATORS)
	typedef pointer                                iterator;
	typedef const_pointer                          const_iterator;
private:
	static pointer        __iterator2pointer(const iterator& i)            {return i;}
	static const_pointer  __iterator2pointer(const const_iterator& i)      {return i;}
	static iterator       __pointer2iterator(const pointer& p)             {return p;}
	static const_iterator __pointer2iterator(const const_pointer& p)       {return p;}
public:
#else
	typedef __wrap_iterator<basic_string, pointer>       iterator;
	typedef __wrap_iterator<basic_string, const_pointer> const_iterator;
private:
	static pointer        __iterator2pointer(const iterator& i)            {return i.base();}
	static const_pointer  __iterator2pointer(const const_iterator& i)      {return i.base();}
	iterator              __pointer2iterator(const pointer& p)             {return iterator(p);}
	const_iterator        __pointer2iterator(const const_pointer& p) const {return const_iterator(p);}
public:
#endif

	typedef _STD::reverse_iterator<iterator>       reverse_iterator;
	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;

#ifdef _MSL_DEBUG
private:
	void __invalidate_all_iterators()
	{
		if (iterator_list<iterator>())
			iterator_list<iterator>()->remove(__unary_true_value<__uncheck_iterator>());
		if (iterator_list<const_iterator>())
			iterator_list<const_iterator>()->remove(__unary_true_value<__uncheck_const_iterator>());
	}

	class __invalidate_on_reallocate
	{
	public:
		__invalidate_on_reallocate(basic_string& v) : vec_(v), old_data_(v.data()) {} 
		~__invalidate_on_reallocate()
		{
			if (old_data_ != vec_.data())
				vec_.__invalidate_all_iterators();
		}
	private:
		basic_string& vec_;
		const_pointer old_data_;

		__invalidate_on_reallocate(const __invalidate_on_reallocate&);
		__invalidate_on_reallocate& operator=(const __invalidate_on_reallocate&);
	};
	friend class __invalidate_on_reallocate;

	void __invalidate_past_end_iterators()
	{
		if (iterator_list<iterator>())
			iterator_list<iterator>()->remove(bind2nd(greater<__uncheck_iterator>(), __uncheck_end()));
		if (iterator_list<const_iterator>())
			iterator_list<const_iterator>()->remove(bind2nd(greater<__uncheck_const_iterator>(), __uncheck_end()));
	}

	class __invalidate_on_shrink
	{
	public:
		__invalidate_on_shrink(basic_string& v) : vec_(v), old_size_(v.size()) {} 
		~__invalidate_on_shrink()
		{
			if (old_size_ < vec_.size())
				vec_.__invalidate_past_end_iterators();
		}
	private:
		basic_string& vec_;
		size_type old_size_;

		__invalidate_on_shrink(const __invalidate_on_shrink&);
		__invalidate_on_shrink& operator=(const __invalidate_on_shrink&);
	};
	friend class __invalidate_on_shrink;

	void __invalidate_iterators_past_pos(size_type pos)
	{
		
		if (iterator_list<iterator>())
			iterator_list<iterator>()->remove(bind2nd(greater_equal<__uncheck_iterator>(), __uncheck_begin()+pos));
		if (iterator_list<const_iterator>())
			iterator_list<const_iterator>()->remove(bind2nd(greater_equal<__uncheck_const_iterator>(), __uncheck_begin()+pos));
	}

	class __invalidate_past_pos
	{
	public:
		__invalidate_past_pos(basic_string& v, basic_string::iterator p) : vec_(v), old_size_(v.size()),
			pos_(size_type(p - vec_.begin())) {} 
		__invalidate_past_pos(basic_string& v, basic_string::size_type p) : vec_(v), old_size_(v.size()),
			pos_(p) {} 
		~__invalidate_past_pos()
		{
			if (old_size_ != vec_.size())
				vec_.__invalidate_iterators_past_pos(pos_);
		}
	private:
		basic_string& vec_;
		size_type old_size_;
		size_type pos_;

		__invalidate_past_pos(const __invalidate_past_pos&);
		__invalidate_past_pos& operator=(const __invalidate_past_pos&);
	};
	friend class __invalidate_past_pos;
public:
#endif

	static const size_type npos = size_type(-1);

	// _lib.string.cons_ construct/copy/destroy:
	explicit basic_string(const Allocator& a = Allocator());
	basic_string(const basic_string& str);
	basic_string(const basic_string& str, size_type pos, size_type n = npos, const Allocator& a = allocator_type());
	basic_string(const charT* s, size_type n, const Allocator& a = Allocator());
	basic_string(const charT* s, const Allocator& a = Allocator());
	basic_string(size_type n, charT c, const Allocator& a = Allocator());
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template<class InputIterator>
		inline
		basic_string(InputIterator begin, InputIterator end, const Allocator& a = Allocator())
		#ifndef _MSL_NO_REFCOUNT_STRING
			: alloc_(CharArray_allocator(a))
		#else
			: alloc_(a)
		#endif
		{
			choose_init(begin, end, a, chooser<numeric_limits<InputIterator>::is_integer>());
		}
	#else
		basic_string (const_iterator begin, const_iterator end, const Allocator& a = Allocator())
		{
			init(begin, end, a, random_access_iterator_tag());
		}
	#endif
	~basic_string();
	basic_string& operator=(const basic_string& str);
	basic_string& operator=(const charT* s);
	basic_string& operator=(charT c);
	// _lib.string.iterators_ iterators:
	iterator       begin();
	const_iterator begin() const;
	iterator       end();
	const_iterator end() const;
#ifdef _MSL_DEBUG
	__uncheck_iterator       __uncheck_begin();
	__uncheck_const_iterator __uncheck_begin() const;
	__uncheck_iterator       __uncheck_end();
	__uncheck_const_iterator __uncheck_end() const;
#endif

	reverse_iterator       rbegin();
	const_reverse_iterator rbegin() const;
	reverse_iterator       rend();
	const_reverse_iterator rend() const;
	// _lib.string.capacity_ capacity:
	size_type size() const;
	size_type length() const;
	size_type max_size() const;
	void resize(size_type n, charT c);
	void resize(size_type n);
	size_type capacity() const;
	void reserve(size_type res_arg = 0);
	void clear();
	bool empty() const;
	// _lib.string.access_ element access:
	const_reference operator[](size_type pos) const;
	reference       operator[](size_type pos);
	const_reference at(size_type pos) const;
	reference       at(size_type pos);
	// _lib.string.modifiers_ modifiers:
	basic_string& operator+=(const basic_string& str);
	basic_string& operator+=(const charT* s);
	basic_string& operator+=(charT c);
	basic_string& append(const basic_string& str);
	basic_string& append(const basic_string& str, size_type pos, size_type n);
	basic_string& append(const charT* s, size_type n);
	basic_string& append(const charT* s);
	basic_string& append(size_type n, charT c);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template<class InputIterator>
		inline
		basic_string& append(InputIterator first, InputIterator last)
		{
			return choose_append(first, last, chooser<numeric_limits<InputIterator>::is_integer>());
		}
	#else
		inline
		basic_string& append(const_iterator first, const_iterator last)
		{
			return do_append(first, last, random_access_iterator_tag());
		}
	#endif
	void push_back(charT c);
	void pop_back();

	basic_string& assign(const basic_string& str);
	basic_string& assign(const basic_string& str, size_type pos, size_type n);
	basic_string& assign(const charT* s, size_type n);
	basic_string& assign(const charT* s);
	basic_string& assign(size_type n, charT c);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template<class InputIterator>
		inline
		basic_string& assign(InputIterator first, InputIterator last)
		{
			return choose_assign(first, last, chooser<numeric_limits<InputIterator>::is_integer>());
		}
	#else
		inline
		basic_string& assign(const_iterator first, const_iterator last)
		{
			return do_assign(first, last, random_access_iterator_tag());
		}
	#endif
	basic_string& insert(size_type pos1, const basic_string& str);
	basic_string& insert(size_type pos1, const basic_string& str, size_type pos2, size_type n);
	basic_string& insert(size_type pos, const charT* s, size_type n);
	basic_string& insert(size_type pos, const charT* s);
	basic_string& insert(size_type pos, size_type n, charT c);
	iterator insert(iterator p, charT c);
	void     insert(iterator p, size_type n, charT c);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template<class InputIterator>
		inline
		void insert(iterator p, InputIterator first, InputIterator last)
		{
			replace(p, p, first, last);
		}
	#else
		void insert(iterator p, const_iterator first, const_iterator last)
		{
			replace(p, p, first, last);
		}
	#endif
	basic_string& erase(size_type pos = 0, size_type n = npos);
	iterator erase(iterator position);
	iterator erase(iterator first, iterator last);
	inline basic_string& replace(size_type pos1, size_type n1, const basic_string& str);
	inline basic_string& replace(size_type pos1, size_type n1, const basic_string& str,
	                      size_type pos2, size_type n2);
	inline basic_string& replace(size_type pos, size_type n1, const charT* s, size_type n2);
	inline basic_string& replace(size_type pos, size_type n1, const charT* s);
	inline basic_string& replace(size_type pos, size_type n1, size_type n2, charT c);
	inline basic_string& replace(iterator i1, iterator i2, const basic_string& str);
	inline basic_string& replace(iterator i1, iterator i2, const charT* s, size_type n);
	inline basic_string& replace(iterator i1, iterator i2, const charT* s);
	inline basic_string& replace(iterator i1, iterator i2, size_type n, charT c);
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		template<class InputIterator>
		inline
		basic_string& replace(iterator i1, iterator i2, InputIterator j1, InputIterator j2)
		{
			return choose_replace(size_type(i1 - begin()), size_type(i2 - i1), j1, j2,
				chooser<numeric_limits<InputIterator>::is_integer>());
		}
	#else
		basic_string& replace(iterator i1, iterator i2, const_iterator j1, const_iterator j2)
		{
			return do_replace(size_type(i1 - begin()), size_type(i2 - i1), j1, j2,
				random_access_iterator_tag());
		}
	#endif
	size_type copy(charT* s, size_type n, size_type pos = 0) const;
	void swap(basic_string<charT,traits,Allocator>& str);
	// _lib.string.ops_ string operations:
	const charT* c_str() const;         // explicit
	const charT* data() const;
	allocator_type get_allocator() const;
	size_type find (const basic_string& str, size_type pos = 0) const;
	size_type find (const charT* s, size_type pos, size_type n) const;
	size_type find (const charT* s, size_type pos = 0) const;
	size_type find (charT c, size_type pos = 0) const;
	size_type rfind(const basic_string& str, size_type pos = npos) const;
	size_type rfind(const charT* s, size_type pos, size_type n) const;
	size_type rfind(const charT* s, size_type pos = npos) const;
	size_type rfind(charT c, size_type pos = npos) const;

	size_type find_first_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_of(const charT* s, size_type pos, size_type n) const;
	size_type find_first_of(const charT* s, size_type pos = 0) const;
	size_type find_first_of(charT c, size_type pos = 0) const;
	size_type find_last_of(const basic_string& str, size_type pos = npos) const;
	size_type find_last_of(const charT* s, size_type pos, size_type n) const;
	size_type find_last_of(const charT* s, size_type pos = npos) const;
	size_type find_last_of(charT c, size_type pos = npos) const;
	size_type find_first_not_of(const basic_string& str, size_type pos = 0) const;
	size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
	size_type find_first_not_of(const charT* s, size_type pos = 0) const;
	size_type find_first_not_of(charT c, size_type pos = 0) const;
	size_type find_last_not_of (const basic_string& str, size_type pos = npos) const;
	size_type find_last_not_of (const charT* s, size_type pos, size_type n) const;
	size_type find_last_not_of (const charT* s, size_type pos = npos) const;
	size_type find_last_not_of (charT c, size_type pos = npos) const;
	basic_string substr(size_type pos = 0, size_type n = npos) const;
	int compare(const basic_string& str) const;
	int compare(size_type pos1, size_type n1, const basic_string& str) const;
	int compare(size_type pos1, size_type n1, const basic_string& str,
	            size_type pos2, size_type n2) const;
	int compare(const charT* s) const;
	int compare(size_type pos1, size_type n1, const charT* s) const;  // hh 990126
	int compare(size_type pos1, size_type n1, const charT* s, size_type n2) const;
private:

#ifndef _MSL_NO_REFCOUNT_STRING

	class CharArray
	{
	public:
		typedef typename Allocator::pointer pointer;
		typedef typename Allocator::size_type size_type;

		// construct/copy/destroy:
		CharArray()
			: alloc_(Allocator(), recommend(0)),
			  refcount_(1),
			  data_(alloc_.allocate(alloc_.m_ + 1))
		{
			traits::assign(*data_, charT());
			size_ = 0;
		}

		CharArray(const Allocator& alloc, size_type capacity = 0)
			: alloc_(alloc, recommend(capacity)),
			  refcount_(1),
			  data_(alloc_.allocate(alloc_.m_ + 1))
		{
		}

		CharArray(const CharArray& rhs)
			: alloc_(rhs.alloc_, recommend(rhs.size_)),
			  size_(rhs.size_),
			  refcount_(1),
			  data_(alloc_.allocate(alloc_.m_ + 1))
		{
			traits::copy(data_, rhs.data_, size_ + 1);
		}

		~CharArray()
		{
			alloc_.deallocate(data_, alloc_.m_ + 1);
		}

		CharArray& operator = (const CharArray& rhs)
		{
			if (this == &rhs)
				return *this;
			if (alloc_.m_ < rhs.size_)
			{
				size_type newsize = recommend(rhs.size_);
				pointer newdata = alloc_.allocate(newsize + 1);
				alloc_.deallocate(data_, alloc_.m_ + 1);
				data_ = newdata;
				alloc_.m_ = newsize;
			}
			size_ = rhs.size_;
			traits::copy(data_, rhs.data_, size_ + 1);
			return *this;
		}

		// capacity
		void reserve(size_type res_arg)
		{
			if (res_arg < size_)
				res_arg = size_;
			res_arg = recommend(res_arg);
			if (res_arg < alloc_.m_)
			{
				#ifndef _MSL_NO_EXCEPTIONS
				try
				{
				#endif
					pointer olddata = data_;
					data_ = alloc_.allocate(res_arg + 1);
					traits::copy(data_, olddata, size_ + 1);
					alloc_.deallocate(olddata, alloc_.m_ + 1);
					alloc_.m_ = res_arg;
				#ifndef _MSL_NO_EXCEPTIONS
				}
				catch (...)
				{
				}
				#endif
			}
			else if (res_arg > alloc_.m_)
			{
				pointer olddata = data_;
				data_ = alloc_.allocate(res_arg + 1);
				traits::copy(data_, olddata, size_ + 1);
				alloc_.deallocate(olddata, alloc_.m_ + 1);
				alloc_.m_ = res_arg;
			}
		}

		size_type capacity() const
		{
			return alloc_.m_;
		}

		// refcounting
		bool sharable() const
		{
			return static_cast<bool>(refcount_ != 0);
		}

		bool is_unique() const
		{
			return static_cast<bool>(refcount_ <= 1);
		}

		CharArray* addRef(CharArray_allocator& alloc)
		{
			_MSL_LOCK_MUTEX(lock, mutex_)
			if (sharable())
			{
				++refcount_;
				return this;
			}
			CharArray* result = alloc.allocate(1);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				alloc.construct(result, *this);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc.deallocate(result, 1);
				throw;
			}
			#endif
			return result;
		}

		CharArray* removeRef()
		{
			_MSL_LOCK_MUTEX(lock, mutex_)
			if (!sharable())
				invalidateReferences();
			return --refcount_ == 0 ? this : 0;
		}

		CharArray* makeUnique(size_type n, CharArray_allocator& alloc, bool copy = true)
		{
			_MSL_LOCK_MUTEX(lock, mutex_)
			if (refcount_ <= 1)
				return this;
			CharArray* result = alloc.allocate(1);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				new (result) CharArray(alloc_, n);
				--refcount_;
				if (copy)
				{
					traits::copy(result->data_, data_, min(n, size_) + 1);
					result->size_ = size_;
				}
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc.deallocate(result, 1);
				throw;
			}
			#endif
			return result;
		}

		void markUnsharable()
		{
			refcount_ = 0;
		}

		void invalidateReferences()
		{
			refcount_ = refcount_ > 0 ? refcount_ : 1;
		}

		// access
		const pointer data() const
		{
			return data_;
		}

		pointer data()
		{
			return data_;
		}

		const allocator_type& get_allocator() const
		{
			return alloc_;
		}

		size_type size_;
	private:
		_EmptyMemberOpt<Allocator, size_type> alloc_;  // m_ is capacity
		size_type refcount_;
		pointer data_;
		_MSL_DECLARE_MUTEX(mutex_)

		static size_type recommend(size_type capacity)
		{
			return capacity + 3 - capacity % 4;
		}
	};

	_EmptyMemberOpt<CharArray_allocator, CharArray*> alloc_;

	pointer __data() {return alloc_.m_->data();}
	const_pointer __data() const {return alloc_.m_->data();}

#else // _MSL_NO_REFCOUNT_STRING

	size_type size_;
	_EmptyMemberOpt<Allocator, size_type> alloc_;  // m_ is capacity
	pointer data_;

	pointer __data() {return data_;}
	const_pointer __data() const {return data_;}

	static size_type recommend(size_type capacity)
	{
		return capacity + 3 - capacity % 4;
	}

#endif // _MSL_NO_REFCOUNT_STRING

#ifdef _MSL_DEBUG
	pair<iterator*, const_iterator*> iterator_list_;

	iterator*&       iterator_list(iterator*)       {return iterator_list_.first;}
	const_iterator*& iterator_list(const_iterator*) {return iterator_list_.second;}
	template <class Iterator>
	Iterator*& iterator_list() {return iterator_list((Iterator*)0);}

	friend class iterator;
	friend class const_iterator;
#endif

#ifndef _MSL_NO_MEMBER_TEMPLATE
	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE

		template<class InputIterator>
		void
		choose_init(InputIterator begin, InputIterator end, const Allocator& a, chooser<true>);

		template<class InputIterator>
		void
		choose_init(InputIterator begin, InputIterator end, const Allocator& a, chooser<false>);

		template<class InputIterator>
		void
		init(InputIterator begin, InputIterator end, const Allocator& a, input_iterator_tag);

		template<class ForwardIterator>
		void
		init(ForwardIterator begin, ForwardIterator end, const Allocator& a, forward_iterator_tag);

		template<class InputIterator>
		basic_string&
		choose_append(InputIterator first, InputIterator last, chooser<true>);

		template<class InputIterator>
		basic_string&
		choose_append(InputIterator first, InputIterator last, chooser<false>);

		template<class InputIterator>
		basic_string&
		do_append(InputIterator first, InputIterator last, input_iterator_tag);

		template<class ForwardIterator>
		basic_string&
		do_append(ForwardIterator first, ForwardIterator last, forward_iterator_tag);

		template<class InputIterator>
		basic_string&
		choose_assign(InputIterator first, InputIterator last, chooser<true>);

		template<class InputIterator>
		basic_string&
		choose_assign(InputIterator first, InputIterator last, chooser<false>);

		template<class InputIterator>
		basic_string&
		do_assign(InputIterator first, InputIterator last, input_iterator_tag);

		template<class ForwardIterator>
		basic_string&
		do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag);

		template<class InputIterator>
		basic_string&
		choose_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
			chooser<true>);

		template<class InputIterator>
		basic_string&
		choose_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
			chooser<false>);

		template<class InputIterator>
		basic_string&
		do_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
			input_iterator_tag);

		template<class ForwardIterator>
		basic_string&
		do_replace(size_type pos, size_type len, ForwardIterator first, ForwardIterator last,
			forward_iterator_tag);

	#else // _MSL_MUST_INLINE_MEMBER_TEMPLATE

		template<class InputIterator>
		inline
		void
		choose_init(InputIterator begin, InputIterator end, const Allocator& a, chooser<true>)
		{
			init(static_cast<size_type>(begin), static_cast<charT>(end), a);
		}

		template<class InputIterator>
		inline
		void
		choose_init(InputIterator begin, InputIterator end, const Allocator& a, chooser<false>)
		{
			init(begin, end, a, typename iterator_traits<InputIterator>::iterator_category());
		}

	#ifndef _MSL_NO_REFCOUNT_STRING

		template<class InputIterator>
		void
		init(InputIterator begin, InputIterator end, const Allocator& a, input_iterator_tag)
		{
			alloc_.m_ = alloc_.allocate(1);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				new (alloc_.m_) CharArray(a);
				alloc_.m_->size_ = 0;
				traits::assign(*alloc_.m_->data(), charT());
				for (; begin != end; ++begin)
					*this += *begin;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(alloc_.m_, 1);
				throw;
			}
			#endif
		}

		template<class ForwardIterator>
		void
		init(ForwardIterator begin, ForwardIterator end, const Allocator& a,
			forward_iterator_tag)
		{
			size_type n = (size_type)_STD::distance(begin, end);
			alloc_.m_ = alloc_.allocate(1);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				new (alloc_.m_) CharArray(a, n);
				alloc_.m_->size_ = n;
				_STD::copy(begin, end, alloc_.m_->data());
				traits::assign(*(alloc_.m_->data() + n), charT());
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(alloc_.m_, 1);
				throw;
			}
			#endif
		}

	#else // _MSL_NO_REFCOUNT_STRING

		template<class InputIterator>
		void
		init(InputIterator begin, InputIterator end, const Allocator&, input_iterator_tag)
		{
			size_ = 0;
			alloc_.m_ = 0;
			data_ = 0;
			if (begin != end)
			{
				#ifndef _MSL_NO_EXCEPTIONS
				try
				{
				#endif
					for (; begin != end; ++begin)
						*this += *begin;
				#ifndef _MSL_NO_EXCEPTIONS
				}
				catch (...)
				{
					if (data_ != 0)
						alloc_.deallocate(data_, alloc_.m_ + 1);
					throw;
				}
				#endif
			}
		}

		template<class ForwardIterator>
		void
		init(ForwardIterator begin, ForwardIterator end, const Allocator&,
			forward_iterator_tag)
		{
			size_ = 0;
			alloc_.m_ = 0;
			data_ = 0;
			size_type n = (size_type)_STD::distance(begin, end);
			if (n > 0)
			{
				size_ = n;
				n = recommend(n);
				data_ = alloc_.allocate(n + 1);
				_STD::copy(begin, end, data_);
				traits::assign(*(data_ + size_), charT());
				alloc_.m_ = n;
			}
		}

	#endif // _MSL_NO_REFCOUNT_STRING

		template<class InputIterator>
		inline
		basic_string&
		choose_append(InputIterator first, InputIterator last, chooser<true>)
		{
			return append(static_cast<size_type>(first), static_cast<charT>(last));
		}

		template<class InputIterator>
		inline
		basic_string&
		choose_append(InputIterator first, InputIterator last, chooser<false>)
		{
			return do_append(first, last, typename iterator_traits<InputIterator>::iterator_category());
		}

		template<class InputIterator>
		basic_string&
		do_append(InputIterator first, InputIterator last, input_iterator_tag)
		{
			basic_string temp(first, last, get_allocator());
			const basic_string& tempr = temp;
			return do_append(tempr.begin(), tempr.end(), random_access_iterator_tag());
		}

		template<class ForwardIterator>
		basic_string&
		do_append(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
		{
			size_type rlen = (size_type)_STD::distance(first, last);
			size_type curlen = size();
			change_size(curlen + rlen);
			_STD::copy(first, last, __data() + curlen);
			return *this;
		}

		template<class InputIterator>
		inline
		basic_string&
		choose_assign(InputIterator first, InputIterator last, chooser<true>)
		{
			return assign(static_cast<size_type>(first), static_cast<charT>(last));
		}

		template<class InputIterator>
		inline
		basic_string&
		choose_assign(InputIterator first, InputIterator last, chooser<false>)
		{
			return do_assign(first, last, typename iterator_traits<InputIterator>::iterator_category());
		}

		template<class InputIterator>
		basic_string&
		do_assign(InputIterator first, InputIterator last, input_iterator_tag)
		{
			basic_string temp(first, last, get_allocator());
			const basic_string& tempr = temp;
			return do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
		}

		template<class ForwardIterator>
		basic_string&
		do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
		{
		#ifdef _MSL_DEBUG
			__invalidate_all_iterators();
		#endif
			size_type rlen = (size_type)_STD::distance(first, last);
			change_size(rlen, false);
			_STD::copy(first, last, __data());
			return *this;
		}

		template<class InputIterator>
		inline
		basic_string&
		choose_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
			chooser<true>)
		{
			return replace(pos, len, static_cast<size_type>(first), static_cast<charT>(last));
		}

		template<class InputIterator>
		inline
		basic_string&
		choose_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
			chooser<false>)
		{
			return do_replace(pos, len, first, last,
				typename iterator_traits<InputIterator>::iterator_category());
		}

		template<class InputIterator>
		basic_string&
		do_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
			input_iterator_tag)
		{
			basic_string temp(first, last, get_allocator());
			const basic_string& tempr = temp;
			return do_replace(pos, len, tempr.begin(), tempr.end(),
				random_access_iterator_tag());
		}

		template<class ForwardIterator>
		basic_string&
		do_replace(size_type pos, size_type len, ForwardIterator first, ForwardIterator last,
			forward_iterator_tag)
		{
			if (pos > size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw out_of_range("basic_string::replace pos out of range");
			#else
				__msl_error("basic_string::replace pos out of range\n");
			#endif
		#ifdef _MSL_DEBUG
			__invalidate_past_pos __p(*this, pos);
			__invalidate_on_shrink __s(*this);
			__invalidate_on_reallocate __c(*this);
		#endif
			size_type xlen = min(len, size() - pos);
			size_type rlen = (size_type)_STD::distance(first, last);
			if (rlen > max_size() || size() - xlen > max_size() - rlen)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("basic_string::replace length error");
			#else
				__msl_error("basic_string::replace length error\n");
			#endif
			size_type nlen = size() - xlen + rlen;
		#ifndef _MSL_NO_REFCOUNT_STRING
			if (!alloc_.m_->is_unique() || nlen > capacity())
		#else
			if (nlen > capacity())
		#endif
			{	// must do with copy
			#ifndef _MSL_NO_REFCOUNT_STRING
				CharArray* temp = alloc_.allocate(1);
				#ifndef _MSL_NO_EXCEPTIONS
				try
				{
				#endif
					new (temp) CharArray(alloc_.m_->get_allocator(), nlen);
					traits::copy(temp->data(), alloc_.m_->data(), pos);
					_STD::copy(first, last, temp->data() + pos);
					traits::copy(temp->data() + pos + rlen, alloc_.m_->data() + pos + xlen,
						size() - (pos + xlen));
					traits::assign(*(temp->data() + nlen), charT());
					temp->size_ = nlen;
					alloc_.m_ = alloc_.m_->removeRef();
					if (alloc_.m_ != 0)
					{
						alloc_.destroy(alloc_.m_);
						alloc_.deallocate(alloc_.m_, 1);
					}
					alloc_.m_ = temp;
				#ifndef _MSL_NO_EXCEPTIONS
				}
				catch (...)
				{
					alloc_.deallocate(temp, 1);
					throw;
				}
				#endif
			#else // _MSL_NO_REFCOUNT_STRING
				pointer temp = alloc_.allocate(recommend(nlen) + 1);
				if (data_ != 0)
					traits::copy(temp, data_, pos);
				_STD::copy(first, last, temp + pos);
				if (data_ != 0)
					traits::copy(temp + pos + rlen, data_ + pos + xlen,
						size() - (pos + xlen));
				traits::assign(*(temp + nlen), charT());
				if (data_ != 0)
					alloc_.deallocate(data_, alloc_.m_ + 1);
				data_ = temp;
				alloc_.m_ = recommend(nlen);
				size_ = nlen;
			#endif // _MSL_NO_REFCOUNT_STRING
			}
			else
			{	// must do inplace
			#ifndef _MSL_NO_REFCOUNT_STRING
				traits::move(alloc_.m_->data() + pos + rlen, alloc_.m_->data() + pos + xlen,
					size() - (pos + xlen));
				_STD::copy(first, last, alloc_.m_->data() + pos);
				traits::assign(*(alloc_.m_->data() + nlen), charT());
				alloc_.m_->size_ = nlen;
			#else // _MSL_NO_REFCOUNT_STRING
				if (data_ != 0)
				{
					traits::move(data_ + pos + rlen, data_ + pos + xlen,
						size() - (pos + xlen));
					_STD::copy(first, last, data_ + pos);
					traits::assign(*(data_ + nlen), charT());
					size_ = nlen;
				}
			#endif // _MSL_NO_REFCOUNT_STRING
			}
			return *this;
		}

	#endif // _MSL_MUST_INLINE_MEMBER_TEMPLATE
#endif // _MSL_NO_MEMBER_TEMPLATE

	void init(pointer begin, pointer end, const Allocator& a, random_access_iterator_tag);  // hh 990826
	void init(const_pointer begin, const_pointer end, const Allocator& a, random_access_iterator_tag);
	void init(size_type n, charT c, const Allocator& a);
	basic_string& do_append(const_pointer first, const_pointer last, random_access_iterator_tag);
	basic_string& do_append(pointer first, pointer last, random_access_iterator_tag);  // hh 991102
	basic_string& do_assign(const_pointer first, const_pointer last, random_access_iterator_tag);
	basic_string& do_assign(pointer first, pointer last, random_access_iterator_tag);  // hh 991102
	basic_string& do_replace(size_type pos, size_type len, const_pointer first, const_pointer last, random_access_iterator_tag);
	basic_string& do_replace(size_type pos, size_type len, pointer first, pointer last, random_access_iterator_tag);  // hh 991102
	void change_size(size_type n, bool copy = true);
};

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
          const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const charT* lhs,
          const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);

template<class charT, class traits, class Allocator>
bool
operator==(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator==(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator!=(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator!=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator!=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator< (const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator< (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator< (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator> (const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator> (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator> (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator<=(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator<=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator<=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator>=(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs);

template<class charT, class traits, class Allocator>
bool
operator>=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs);

template<class charT, class traits, class Allocator>
bool
operator>=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs);

// _lib.string.special_:
template<class charT, class traits, class Allocator>
void
swap(basic_string<charT,traits,Allocator>& lhs, basic_string<charT,traits,Allocator>& rhs);

#ifndef _MSL_NO_IO

template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
operator>>(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator << (basic_ostream<charT, traits>& os, const basic_string<charT,traits,Allocator>& str);

#endif // _MSL_NO_IO

// Implementation

#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	void
	basic_string<charT, traits, Allocator>::choose_init(InputIterator begin, InputIterator end, const Allocator& a, chooser<true>)
	{
		init(static_cast<size_type>(begin), static_cast<charT>(end), a);
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	void
	basic_string<charT, traits, Allocator>::choose_init(InputIterator begin, InputIterator end, const Allocator& a, chooser<false>)
	{
		init(begin, end, a, typename iterator_traits<InputIterator>::iterator_category());
	}

#ifndef _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	void
	basic_string<charT, traits, Allocator>::init(InputIterator begin, InputIterator end, const Allocator& a, input_iterator_tag)
	{
		alloc_.m_ = alloc_.allocate(1);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			new (alloc_.m_) CharArray(a);
			alloc_.m_->size_ = 0;
			traits::assign(*alloc_.m_->data(), charT());
			for (; begin != end; ++begin)
				*this += *begin;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(alloc_.m_, 1);
			throw;
		}
		#endif
	}

	template<class charT, class traits, class Allocator>
	template<class ForwardIterator>
	void
	basic_string<charT, traits, Allocator>::init(ForwardIterator begin, ForwardIterator end, const Allocator& a,
		forward_iterator_tag)
	{
		size_type n = (size_type)_STD::distance(begin, end);
		alloc_.m_ = alloc_.allocate(1);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			new (alloc_.m_) CharArray(a, n);
			alloc_.m_->size_ = n;
			_STD::copy(begin, end, alloc_.m_->data());
			traits::assign(*(alloc_.m_->data() + n), charT());
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(alloc_.m_, 1);
			throw;
		}
		#endif
	}

#else // _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	void
	basic_string<charT, traits, Allocator>::init(InputIterator begin, InputIterator end, const Allocator&, input_iterator_tag)
	{
		size_ = 0;
		alloc_.m_ = 0;
		data_ = 0;
		if (begin != end)
		{
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				for (; begin != end; ++begin)
					*this += *begin;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				if (data_ != 0)
					alloc_.deallocate(data_, alloc_.m_ + 1);
				throw;
			}
			#endif
		}
	}

	template<class charT, class traits, class Allocator>
	template<class ForwardIterator>
	void
	basic_string<charT, traits, Allocator>::init(ForwardIterator begin, ForwardIterator end, const Allocator&,
		forward_iterator_tag)
	{
		size_ = 0;
		alloc_.m_ = 0;
		data_ = 0;
		size_type n = (size_type)_STD::distance(begin, end);
		if (n > 0)
		{
			size_ = n;
			n = recommend(n);
			data_ = alloc_.allocate(n + 1);
			_STD::copy(begin, end, data_);
			traits::assign(*(data_ + n), charT());
			alloc_.m_ = n;
		}
	}

#endif // _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::choose_append(InputIterator first, InputIterator last, chooser<true>)
	{
		return append(static_cast<size_type>(first), static_cast<charT>(last));
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::choose_append(InputIterator first, InputIterator last, chooser<false>)
	{
		return do_append(first, last, typename iterator_traits<InputIterator>::iterator_category());
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::do_append(InputIterator first, InputIterator last, input_iterator_tag)
	{
		basic_string temp(first, last, get_allocator());
		const basic_string& tempr = temp;
		return do_append(tempr.begin(), tempr.end(), random_access_iterator_tag());
	}

	template<class charT, class traits, class Allocator>
	template<class ForwardIterator>
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::do_append(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
	{
		size_type rlen = (size_type)_STD::distance(first, last);
		size_type curlen = size();
		change_size(curlen + rlen);
		_STD::copy(first, last, __data() + curlen);
		return *this;
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<true>)
	{
		return assign(static_cast<size_type>(first), static_cast<charT>(last));
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<false>)
	{
		return do_assign(first, last, typename iterator_traits<InputIterator>::iterator_category());
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::do_assign(InputIterator first, InputIterator last, input_iterator_tag)
	{
		basic_string temp(first, last, get_allocator());
		const basic_string& tempr = temp;
		return do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());
	}

	template<class charT, class traits, class Allocator>
	template<class ForwardIterator>
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)
	{
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
		size_type rlen = (size_type)_STD::distance(first, last);
		change_size(rlen, false);
		_STD::copy(first, last, __data());
		return *this;
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::choose_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
		chooser<true>)
	{
		return replace(pos, len, static_cast<size_type>(first), static_cast<charT>(last));
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	inline
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::choose_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
		chooser<false>)
	{
		return do_replace(pos, len, first, last,
			typename iterator_traits<InputIterator>::iterator_category());
	}

	template<class charT, class traits, class Allocator>
	template<class InputIterator>
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::do_replace(size_type pos, size_type len, InputIterator first, InputIterator last,
		input_iterator_tag)
	{
		basic_string temp(first, last, get_allocator());
		const basic_string& tempr = temp;
		return do_replace(pos, len, tempr.begin(), tempr.end(),
			random_access_iterator_tag());
	}

	template<class charT, class traits, class Allocator>
	template<class ForwardIterator>
	basic_string<charT, traits, Allocator>&
	basic_string<charT, traits, Allocator>::do_replace(size_type pos, size_type len, ForwardIterator first, ForwardIterator last,
		forward_iterator_tag)
	{
		if (pos > size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::replace pos out of range");
		#else
			__msl_error("basic_string::replace pos out of range\n");
		#endif
	#ifdef _MSL_DEBUG
		__invalidate_past_pos __p(*this, pos);
		__invalidate_on_shrink __s(*this);
		__invalidate_on_reallocate __c(*this);
	#endif
		size_type xlen = min(len, size() - pos);
		size_type rlen = (size_type)_STD::distance(first, last);
		if (rlen > max_size() || size() - xlen > max_size() - rlen)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("basic_string::replace length error");
		#else
			__msl_error("basic_string::replace length error\n");
		#endif
		size_type nlen = size() - xlen + rlen;
	#ifndef _MSL_NO_REFCOUNT_STRING
		if (!alloc_.m_->is_unique() || nlen > capacity())
	#else
		if (nlen > capacity())
	#endif
		{	// must do with copy
		#ifndef _MSL_NO_REFCOUNT_STRING
			CharArray* temp = alloc_.allocate(1);
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				new (temp) CharArray(alloc_.m_->get_allocator(), nlen);
				traits::copy(temp->data(), alloc_.m_->data(), pos);
				_STD::copy(first, last, temp->data() + pos);
				traits::copy(temp->data() + pos + rlen, alloc_.m_->data() + pos + xlen,
					size() - (pos + xlen));
				traits::assign(*(temp->data() + nlen), charT());
				temp->size_ = nlen;
				alloc_.m_ = alloc_.m_->removeRef();
				if (alloc_.m_ != 0)
				{
					alloc_.destroy(alloc_.m_);
					alloc_.deallocate(alloc_.m_, 1);
				}
				alloc_.m_ = temp;
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				alloc_.deallocate(temp, 1);
				throw;
			}
			#endif
		#else // _MSL_NO_REFCOUNT_STRING
			pointer temp = alloc_.allocate(recommend(nlen) + 1);
			if (data_ != 0)
				traits::copy(temp, data_, pos);
			_STD::copy(first, last, temp + pos);
			if (data_ != 0)
				traits::copy(temp + pos + rlen, data_ + pos + xlen,
					size() - (pos + xlen));
			traits::assign(*(temp + nlen), charT());
			if (data_ != 0)
				alloc_.deallocate(data_, alloc_.m_ + 1);
			data_ = temp;
			alloc_.m_ = recommend(nlen);
			size_ = nlen;
		#endif // _MSL_NO_REFCOUNT_STRING
		}
		else
		{	// must do inplace
		#ifndef _MSL_NO_REFCOUNT_STRING
			traits::move(alloc_.m_->data() + pos + rlen, alloc_.m_->data() + pos + xlen,
				size() - (pos + xlen));
			_STD::copy(first, last, alloc_.m_->data() + pos);
			traits::assign(*(alloc_.m_->data() + nlen), charT());
			alloc_.m_->size_ = nlen;
		#else // _MSL_NO_REFCOUNT_STRING
			if (data_ != 0)
			{
				traits::move(data_ + pos + rlen, data_ + pos + xlen,
					size() - (pos + xlen));
				_STD::copy(first, last, data_ + pos);
				traits::assign(*(data_ + nlen), charT());
				size_ = nlen;
			}
		#endif // _MSL_NO_REFCOUNT_STRING
		}
		return *this;
	}

#endif // _MSL_MUST_INLINE_MEMBER_TEMPLATE
#endif // _MSL_NO_MEMBER_TEMPLATE

#ifndef _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	basic_string<charT, traits, Allocator>::basic_string(const Allocator& a)
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		: alloc_(CharArray_allocator(a))
	#endif
	{
		alloc_.m_ = alloc_.allocate(1);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			new (alloc_.m_) CharArray(a);
			traits::assign(*alloc_.m_->data(), charT());
			alloc_.m_->size_ = 0;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(alloc_.m_, 1);
			throw;
		}
		#endif
	}

#else // _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	inline
	basic_string<charT, traits, Allocator>::basic_string(const Allocator& a)
		: size_(0),
	#ifndef _MSL_NO_MEMBER_TEMPLATE
		  alloc_(a),
	#endif
		  data_(0)
	{
		alloc_.m_ = 0;
	}

#endif // _MSL_NO_REFCOUNT_STRING

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>::basic_string(const basic_string& str)
#ifndef _MSL_NO_MEMBER_TEMPLATE
	: alloc_(str.alloc_)
#endif
{
#ifndef _MSL_NO_REFCOUNT_STRING
	alloc_.m_ = str.alloc_.m_->addRef(alloc_);
#else
	init(str.data_, str.data_ + str.size(), get_allocator(), random_access_iterator_tag());
#endif
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>::basic_string(const basic_string& str, size_type pos,
	size_type n, const Allocator& a)
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_NO_REFCOUNT_STRING
	: alloc_(CharArray_allocator(a))
#else
	: alloc_(a)
#endif
#endif
{
	size_type strLen = str.size();
	if (pos > strLen)
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("string copy constructor: pos > str len");
		#else
			__msl_error("string copy constructor: pos > str len\n");
		#endif
	size_type rlen = strLen - pos;
	if (rlen > n)
		rlen = n;
#ifndef _MSL_NO_REFCOUNT_STRING
	if (rlen == strLen && alloc_ == str.alloc_)
		alloc_.m_ = str.alloc_.m_->addRef(alloc_);
	else
		init(str.alloc_.m_->data() + pos, str.alloc_.m_->data() + pos + rlen, a, random_access_iterator_tag());
#else
		init(str.data_ + pos, str.data_ + pos + rlen, a, random_access_iterator_tag());
#endif
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>::basic_string(const charT* s, size_type n,
	const Allocator& a)
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_NO_REFCOUNT_STRING
	: alloc_(CharArray_allocator(a))
#else
	: alloc_(a)
#endif
#endif
{
	if (n > a.max_size()-1)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("string constructor: n > max_size");
		#else
			__msl_error("string constructor: n > max_size\n");
		#endif
	init(s, s + n, a, random_access_iterator_tag());
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>::basic_string(const charT* s, const Allocator& a)
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_NO_REFCOUNT_STRING
	: alloc_(CharArray_allocator(a))
#else
	: alloc_(a)
#endif
#endif
{
	size_type n = traits::length(s);
	if (n > a.max_size()-1)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("string constructor: n > max_size");
		#else
			__msl_error("string constructor: n > max_size\n");
		#endif
	init(s, s + n, a, random_access_iterator_tag());
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>::basic_string(size_type n, charT c, const Allocator& a)
#ifndef _MSL_NO_MEMBER_TEMPLATE
#ifndef _MSL_NO_REFCOUNT_STRING
	: alloc_(CharArray_allocator(a))
#else
	: alloc_(a)
#endif
#endif
{
	init(n, c, a);
}

// hh 990826
template<class charT, class traits, class Allocator>
inline
void
basic_string<charT, traits, Allocator>::init(pointer begin, pointer end,
	const Allocator& a, random_access_iterator_tag)
{
	init(static_cast<const_pointer>(begin), static_cast<const_pointer>(end), a,
		random_access_iterator_tag());
}

#ifndef _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::init(const_pointer begin, const_pointer end,
		const Allocator& a, random_access_iterator_tag)
	{
		alloc_.m_ = alloc_.allocate(1);
		size_type len = size_type(end - begin);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			new (alloc_.m_) CharArray(a, len);
			traits::copy(alloc_.m_->data(), begin, len);
			alloc_.m_->size_ = len;
			traits::assign(*(alloc_.m_->data() + len), charT());
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(alloc_.m_, 1);
			throw;
		}
		#endif
	}

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::init(size_type n, charT c, const Allocator& a)
	{
		if (n > a.max_size()-1)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("string constructor: n > max_size");
			#else
				__msl_error("string constructor: n > max_size\n");
			#endif
		alloc_.m_ = alloc_.allocate(1);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			new (alloc_.m_) CharArray(a, n);
			traits::assign(alloc_.m_->data(), n, c);
			alloc_.m_->size_ = n;
			traits::assign(*(alloc_.m_->data() + n), charT());
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(alloc_.m_, 1);
			throw;
		}
		#endif
	}

	template<class charT, class traits, class Allocator>
	basic_string<charT, traits, Allocator>::~basic_string()
	{
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
		alloc_.m_ = alloc_.m_->removeRef();
		if (alloc_.m_ != 0)
		{
			alloc_.destroy(alloc_.m_);
			alloc_.deallocate(alloc_.m_, 1);
		}
	}

#else // _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::init(const_pointer begin, const_pointer end,
		const Allocator&, random_access_iterator_tag)
	{
		data_ = 0;
		size_ = 0;
		alloc_.m_ = 0;
		if (begin != end)
		{
			size_type len = size_type(end - begin);
			alloc_.m_ = recommend(len);
			data_ = alloc_.allocate(alloc_.m_ + 1);
			traits::copy(data_, begin, len);
			size_ = len;
			traits::assign(*(data_ + len), charT());
		}
	}

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::init(size_type n, charT c, const Allocator&)
	{
		data_ = 0;
		size_ = 0;
		alloc_.m_ = 0;
		if (n > 0)
		{
			if (n > max_size())
				#ifndef _MSL_NO_EXCEPTIONS
					throw length_error("string constructor: n > max_size");
				#else
					__msl_error("string constructor: n > max_size\n");
				#endif
			alloc_.m_ = recommend(n);
			data_ = alloc_.allocate(alloc_.m_ + 1);
			traits::assign(data_, n, c);
			size_ = n;
			traits::assign(*(data_ + n), charT());
		}
	}

	template<class charT, class traits, class Allocator>
	basic_string<charT, traits, Allocator>::~basic_string()
	{
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
		if (data_ != 0)
			alloc_.deallocate(data_, alloc_.m_ + 1);
	}

#endif // _MSL_NO_REFCOUNT_STRING

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::operator=(const basic_string& str)
{
	return assign(str);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::operator=(const charT* s)
{
	return assign(s);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::operator=(charT c)
{
	return assign(1, c);
}

template<class charT, class traits, class Allocator>
#ifdef _MSL_NO_REFCOUNT_STRING
inline
#endif
typename basic_string<charT, traits, Allocator>::iterator
basic_string<charT, traits, Allocator>::begin()
{
#ifndef _MSL_NO_REFCOUNT_STRING
	if (!alloc_.m_->is_unique())
	{
		alloc_.m_ = alloc_.m_->makeUnique(alloc_.m_->size_, alloc_);
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
	}
	alloc_.m_->markUnsharable();
#endif
	return __pointer2iterator(__data());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::const_iterator
basic_string<charT, traits, Allocator>::begin() const
{
	return __pointer2iterator(__data());
}

template<class charT, class traits, class Allocator>
#ifdef _MSL_NO_REFCOUNT_STRING
inline
#endif
typename basic_string<charT, traits, Allocator>::iterator
basic_string<charT, traits, Allocator>::end()
{
#ifndef _MSL_NO_REFCOUNT_STRING
	if (!alloc_.m_->is_unique())
	{
		alloc_.m_ = alloc_.m_->makeUnique(alloc_.m_->size_, alloc_);
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
	}
	alloc_.m_->markUnsharable();
#endif
	return __pointer2iterator(__data() + size());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::const_iterator
basic_string<charT, traits, Allocator>::end() const
{
	return __pointer2iterator(__data() + size());
}

#ifdef _MSL_DEBUG

	template<class charT, class traits, class Allocator>
	#ifdef _MSL_NO_REFCOUNT_STRING
	inline
	#endif
	typename basic_string<charT, traits, Allocator>::__uncheck_iterator
	basic_string<charT, traits, Allocator>::__uncheck_begin()
	{
	#ifndef _MSL_NO_REFCOUNT_STRING
		if (!alloc_.m_->is_unique())
		{
			alloc_.m_ = alloc_.m_->makeUnique(alloc_.m_->size_, alloc_);
			__invalidate_all_iterators();
		}
		alloc_.m_->markUnsharable();
	#endif
		return __data();
	}

	template<class charT, class traits, class Allocator>
	inline
	typename basic_string<charT, traits, Allocator>::__uncheck_const_iterator
	basic_string<charT, traits, Allocator>::__uncheck_begin() const
	{
		return __data();
	}

	template<class charT, class traits, class Allocator>
	#ifdef _MSL_NO_REFCOUNT_STRING
	inline
	#endif
	typename basic_string<charT, traits, Allocator>::__uncheck_iterator
	basic_string<charT, traits, Allocator>::__uncheck_end()
	{
	#ifndef _MSL_NO_REFCOUNT_STRING
		if (!alloc_.m_->is_unique())
		{
			alloc_.m_ = alloc_.m_->makeUnique(alloc_.m_->size_, alloc_);
			__invalidate_all_iterators();
		}
		alloc_.m_->markUnsharable();
	#endif
		return __data() + size();
	}

	template<class charT, class traits, class Allocator>
	inline
	typename basic_string<charT, traits, Allocator>::__uncheck_const_iterator
	basic_string<charT, traits, Allocator>::__uncheck_end() const
	{
		return __data() + size();
	}

#endif

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::reverse_iterator
basic_string<charT, traits, Allocator>::rbegin()
{
	return reverse_iterator(end());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::const_reverse_iterator
basic_string<charT, traits, Allocator>::rbegin() const
{
	return const_reverse_iterator(end());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::reverse_iterator
basic_string<charT, traits, Allocator>::rend()
{
	return reverse_iterator(begin());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::const_reverse_iterator
basic_string<charT, traits, Allocator>::rend() const
{
	return const_reverse_iterator(begin());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::size() const
{
#ifndef _MSL_NO_REFCOUNT_STRING
	return alloc_.m_->size_;
#else
	return size_;
#endif
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::length() const
{
#ifndef _MSL_NO_REFCOUNT_STRING
	return alloc_.m_->size_;
#else
	return size_;
#endif
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::max_size() const
{
#ifndef _MSL_NO_REFCOUNT_STRING
	return alloc_.m_->get_allocator().max_size() - 1;
#else
	return get_allocator().max_size() - 1;
#endif
}

template<class charT, class traits, class Allocator>
void
basic_string<charT, traits, Allocator>::resize(size_type n, charT c)
{
#ifdef _MSL_DEBUG
	__invalidate_on_shrink __s(*this);
#endif
	size_type oldsize = size();
	change_size(n);
	if (oldsize < n)
		traits::assign(__data() + oldsize, n - oldsize, c);
}

template<class charT, class traits, class Allocator>
inline
void
basic_string<charT, traits, Allocator>::resize(size_type n)
{
	resize(n, charT());
}

#ifndef _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::change_size(size_type n, bool copy)
	{
		if (n > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("basic_string::length error.  Resizing out of range");
			#else
				__msl_error("basic_string::length error.  Resizing out of range\n");
			#endif
		if (!alloc_.m_->is_unique())
		{
			alloc_.m_ = alloc_.m_->makeUnique(n, alloc_, copy);
		#ifdef _MSL_DEBUG
			__invalidate_all_iterators();
		#endif
		}
		if (n > alloc_.m_->capacity())
		{
			size_type newsize = alloc_.m_->capacity();
			while (newsize < n)
				newsize *= 2;
			alloc_.m_->reserve(newsize);
		#ifdef _MSL_DEBUG
			__invalidate_all_iterators();
		#endif
		}
		traits::assign(*(alloc_.m_->data() + n), charT());
		alloc_.m_->size_ = n;
		alloc_.m_->invalidateReferences();
	}

#else // _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::change_size(size_type n, bool copy)
	{
		if (n > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("basic_string::length error.  Resizing out of range");
			#else
				__msl_error("basic_string::length error.  Resizing out of range\n");
			#endif
		if (n > alloc_.m_)
		{
			size_type newsize = max(alloc_.m_, recommend(1));
			while (newsize < n)
				newsize = recommend(newsize * 2);
			pointer temp = alloc_.allocate(newsize + 1);
			if (data_ != 0)
			{
				if (copy)
					_STD::copy(data_, data_ + size_, temp);
				alloc_.deallocate(data_, alloc_.m_ + 1);
			}
			data_ = temp;
			alloc_.m_ = newsize;
		#ifdef _MSL_DEBUG
			__invalidate_all_iterators();
		#endif
		}
		if (data_)
			traits::assign(*(data_ + n), charT());
		size_ = n;
	}

#endif // _MSL_NO_REFCOUNT_STRING

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::capacity() const
{
#ifndef _MSL_NO_REFCOUNT_STRING
	return alloc_.m_->capacity();
#else
	return alloc_.m_;
#endif
}

#ifndef _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::reserve(size_type res_arg)
	{
		if (res_arg > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("basic_string::reserve argument out of range");
			#else
				__msl_error("basic_string::reserve argument out of range\n");
			#endif
	#ifdef _MSL_DEBUG
		__invalidate_on_reallocate __c(*this);
	#endif
		if (res_arg < alloc_.m_->size_)
			res_arg = alloc_.m_->size_;
		if (!alloc_.m_->is_unique())
		{
			alloc_.m_ = alloc_.m_->makeUnique(res_arg, alloc_);
		}
		alloc_.m_->reserve(res_arg);
		alloc_.m_->invalidateReferences();
	}

#else // _MSL_NO_REFCOUNT_STRING

	template<class charT, class traits, class Allocator>
	void
	basic_string<charT, traits, Allocator>::reserve(size_type res_arg)
	{
		if (res_arg > max_size())
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("basic_string::reserve argument out of range");
			#else
				__msl_error("basic_string::reserve argument out of range\n");
			#endif
	#ifdef _MSL_DEBUG
		__invalidate_on_reallocate __c(*this);
	#endif
		if (res_arg < size_)
			res_arg = size_;
		res_arg = recommend(res_arg);
		if (res_arg != alloc_.m_)
		{
			pointer temp = alloc_.allocate(res_arg + 1);
			if (data_ != 0)
			{
				_STD::copy(data_, data_ + size_ + 1, temp);
				alloc_.deallocate(data_, alloc_.m_ + 1);
			}
			else
				traits::assign(*temp, charT());
			data_ = temp;
			alloc_.m_ = res_arg;
		}
	}

#endif // _MSL_NO_REFCOUNT_STRING

template<class charT, class traits, class Allocator>
inline
void
basic_string<charT, traits, Allocator>::clear()
{
#ifdef _MSL_DEBUG
	__invalidate_all_iterators();
#endif
	change_size(0, false);
}

template<class charT, class traits, class Allocator>
inline
bool
basic_string<charT, traits, Allocator>::empty() const
{
	return size() == 0;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::const_reference
basic_string<charT, traits, Allocator>::operator[](size_type pos) const
{
#ifdef _MSL_DEBUG
	if (pos > size())
	#ifndef _MSL_NO_EXCEPTIONS
		throw out_of_range("basic_string::at index out of range");
	#else
		__msl_error("basic_string::at index out of range");
	#endif
#endif
	return *(__data() + pos);
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::reference
basic_string<charT, traits, Allocator>::operator[](size_type pos)
{
#ifndef _MSL_DEBUG
#ifndef _MSL_NO_REFCOUNT_STRING
	if (!alloc_.m_->is_unique())
	{
		alloc_.m_ = alloc_.m_->makeUnique(alloc_.m_->size_, alloc_);
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
	}
	alloc_.m_->markUnsharable();
#endif
	return *(__data() + pos);
#else
	return at(pos);
#endif
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::const_reference
basic_string<charT, traits, Allocator>::at(size_type pos) const
{
	if (pos >= size())
	#ifndef _MSL_NO_EXCEPTIONS
		throw out_of_range("basic_string::at index out of range");
	#else
		__msl_error("basic_string::at index out of range");
	#endif
	return *(__data() + pos);
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::reference
basic_string<charT, traits, Allocator>::at(size_type pos)
{
	if (pos >= size())
	#ifndef _MSL_NO_EXCEPTIONS
		throw out_of_range("basic_string::at index out of range");
	#else
		__msl_error("basic_string::at index out of range");
	#endif
#ifndef _MSL_NO_REFCOUNT_STRING
	if (!alloc_.m_->is_unique())
	{
		alloc_.m_ = alloc_.m_->makeUnique(alloc_.m_->size_, alloc_);
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
	}
	alloc_.m_->markUnsharable();
#endif
	return *(__data() + pos);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::operator+=(const basic_string& str)
{
	return append(str);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::operator+=(const charT* s)
{
	return append(s);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::operator+=(charT c)
{
	return append(1, c);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::append(const basic_string& str)
{
	return append(str, 0, npos);
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::append(const basic_string& str, size_type pos, size_type n)
{
	if (pos > str.size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::append pos out of range");
		#else
			__msl_error("basic_string::append pos out of range");
		#endif
	size_type rlen = min(n, str.size() - pos);
	if (rlen > 0)
	{	// ok if this == &str
		size_type curlen = size();
		change_size(curlen + rlen);
		traits::copy(__data() + curlen, str.__data() + pos, rlen);
	}
	return *this;
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::append(const charT* s, size_type n)
{
	if (n > 0)
	{
		size_type curlen = size();
		if (__data() <= s && s < __data() + curlen && curlen + n > capacity())
			append(basic_string(s, n));
		else
		{
			change_size(curlen + n);
			traits::copy(__data() + curlen, s, n);
		}
	}
	return *this;
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::append(const charT* s)
{
	return append(s, traits::length(s));
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::append(size_type n, charT c)
{
	if (n > 0)
	{
		if (n > max_size() || size() > max_size() - n)
			#ifndef _MSL_NO_EXCEPTIONS
				throw length_error("basic_string::append results in string > max_size");
			#else
				__msl_error("basic_string::append results in string > max_size");
			#endif
		size_type curlen = size();
		change_size(curlen + n);
		traits::assign(__data() + curlen, n, c);
	}
	return *this;
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::do_append(const_pointer first, const_pointer last,
	random_access_iterator_tag)
{
	size_type rlen = (size_type)(last - first);
	size_type curlen = size();
	if (__data() <= first && first < __data() + curlen && curlen + rlen > capacity())
		append(basic_string(first, last));
	else
	{
		change_size(curlen + rlen);
		traits::copy(__data() + curlen, first, rlen);
	}
	return *this;
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::do_append(pointer first, pointer last,
	random_access_iterator_tag)
{
	return do_append(static_cast<const_pointer>(first), static_cast<const_pointer>(last),
		random_access_iterator_tag());
}

template<class charT, class traits, class Allocator>
inline
void
basic_string<charT, traits, Allocator>::push_back(charT c)
{
	append(1, c);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::assign(const basic_string& str)
{
	return assign(str, 0, npos);
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::assign(const basic_string& str, size_type pos,
	size_type n)
{
	if (pos > str.size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::assign pos out of range");
		#else
			__msl_error("basic_string::assign pos out of range");
		#endif
#ifdef _MSL_DEBUG
	__invalidate_all_iterators();
#endif
	size_type rlen = min(n, str.size() - pos);
#ifndef _MSL_NO_REFCOUNT_STRING
	if (rlen == str.size() && alloc_ == str.alloc_ && str.alloc_.m_->sharable())
	{
		if (alloc_.m_ == str.alloc_.m_)
			return *this;
		alloc_.m_ = alloc_.m_->removeRef();
		if (alloc_.m_ != 0)
		{
			alloc_.destroy(alloc_.m_);
			alloc_.deallocate(alloc_.m_, 1);
		}
		alloc_.m_ = str.alloc_.m_->addRef(alloc_);
	}
	else
	{
#endif
		if (this == &str)
		{
			erase(0, pos);
			change_size(rlen);
		}
		else
		{
			change_size(rlen, false);
			traits::copy(__data(), str.__data() + pos, rlen);
		}
#ifndef _MSL_NO_REFCOUNT_STRING
	}
#endif
	return *this;
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::assign(const charT* s, size_type n)
{
#ifdef _MSL_DEBUG
	__invalidate_all_iterators();
#endif
	change_size(n, false);
	traits::copy(__data(), s, n);
	return *this;
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::assign(const charT* s)
{
	return assign(s, traits::length(s));
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::assign(size_type n, charT c)
{
#ifdef _MSL_DEBUG
	__invalidate_all_iterators();
#endif
	change_size(n, false);
	traits::assign(__data(), n, c);
	return *this;
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::do_assign(const_pointer first, const_pointer last,
	random_access_iterator_tag)
{
#ifdef _MSL_DEBUG
	__invalidate_all_iterators();
#endif
	size_type rlen = (size_type)(last - first);
	if (__data() <= first && first < __data() + size())
	{
	#ifndef _MSL_NO_REFCOUNT_STRING
		if (!alloc_.m_->is_unique())
		{
			alloc_.m_ = alloc_.m_->makeUnique(size(), alloc_, true);
		}
	#endif
		traits::move(__data(), first, rlen);
		change_size(rlen, true);
	}
	else
	{
		change_size(rlen, false);
		traits::copy(__data(), first, rlen);
	}
	return *this;
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::do_assign(pointer first, pointer last,
	random_access_iterator_tag)
{
	return do_assign(static_cast<const_pointer>(first), static_cast<const_pointer>(last),
		random_access_iterator_tag());
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::insert(size_type pos1, const basic_string& str)
{
	return insert(pos1, str, 0, npos);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::insert(size_type pos1, const basic_string& str,
	size_type pos2, size_type n)
{
	return replace(pos1, 0, str, pos2, n);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::insert(size_type pos, const charT* s, size_type n)
{
	return replace(pos, 0, s, n);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::insert(size_type pos, const charT* s)
{
	return insert(pos, s, traits::length(s));
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::insert(size_type pos, size_type n, charT c)
{
	return replace(pos, 0, n, c);
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::iterator
basic_string<charT, traits, Allocator>::insert(iterator p, charT c)
{
	size_type pos = size_type(p - begin());
	replace(pos, 0, 1, c);
	return begin() + difference_type(pos);
}

template<class charT, class traits, class Allocator>
inline
void
basic_string<charT, traits, Allocator>::insert(iterator p, size_type n, charT c)
{
	replace(p, p, n, c);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::erase(size_type pos, size_type n)
{
	return replace(pos, n, 0, charT());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::iterator
basic_string<charT, traits, Allocator>::erase(iterator position)
{
	size_type pos = size_type(position - begin());
	replace(pos, 1, 0, charT());
	return begin() + difference_type(pos);
}

template<class charT, class traits, class Allocator>
inline
void
basic_string<charT, traits, Allocator>::pop_back()
{
	replace(size()-1, 1, 0, charT());
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::iterator
basic_string<charT, traits, Allocator>::erase(iterator first, iterator last)
{
#ifdef _MSL_DEBUG
	if (first > last)
		_MSL_DEBUG_ERROR(logic_error, "MSL DEBUG: invalid iterator range given to string::erase");
#endif
	size_type pos = size_type(first - begin());
	replace(pos, size_type(last - first), 0, charT());
	return begin() + difference_type(pos);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(size_type pos1, size_type n1,
	const basic_string& str)
{
	return replace(pos1, n1, str, 0, npos);
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(size_type pos1, size_type n1,
	const basic_string& str, size_type pos2, size_type n2)
{
	if (pos2 > str.size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::replace pos out of range");
		#else
			__msl_error("basic_string::replace pos out of range\n");
		#endif
	size_type rlen = min(n2, str.size() - pos2);
	if (this == &str)
	{
		const basic_string temp(str, 0, npos, str.get_allocator());
		return do_replace(pos1, n1, temp.begin() + difference_type(pos2),
			temp.begin() + difference_type(pos2 + rlen), random_access_iterator_tag());
	}
	return do_replace(pos1, n1, str.begin() + difference_type(pos2), str.begin()
		+ difference_type(pos2 + rlen), random_access_iterator_tag());
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(size_type pos, size_type n1, const charT* s,
	size_type n2)
{
	return do_replace(pos, n1, s, s + n2, random_access_iterator_tag());
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(size_type pos, size_type n1, const charT* s)
{
	return replace(pos, n1, s, traits::length(s));
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(size_type pos, size_type n1, size_type n2,
	charT c)
{
	if (pos > size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::replace pos out of range");
		#else
			__msl_error("basic_string::replace pos out of range\n");
		#endif
	size_type xlen = min(n1, size() - pos);
	if (n2 > max_size() || size() - xlen > max_size() - n2)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("basic_string::replace length error");
		#else
			__msl_error("basic_string::length error\n");
		#endif
#ifdef _MSL_DEBUG
	__invalidate_past_pos __p(*this, pos);
	__invalidate_on_shrink __s(*this);
	__invalidate_on_reallocate __c(*this);
#endif
	size_type nlen = size() - xlen + n2;
#ifndef _MSL_NO_REFCOUNT_STRING
	if (!alloc_.m_->is_unique() || nlen > capacity())
#else
	if (nlen > capacity())
#endif
	{	// must do with copy
	#ifndef _MSL_NO_REFCOUNT_STRING
		CharArray* temp = alloc_.allocate(1);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			new (temp) CharArray(alloc_.m_->get_allocator(), nlen);
			traits::copy(temp->data(), alloc_.m_->data(), pos);
			if (n2 > 0)
				traits::assign(temp->data() + pos, n2, c);
			traits::copy(temp->data() + pos + n2, alloc_.m_->data() + pos + xlen,
				size() - (pos + xlen));
			traits::assign(*(temp->data() + nlen), charT());
			temp->size_ = nlen;
			alloc_.m_ = alloc_.m_->removeRef();
			if (alloc_.m_ != 0)
			{
				alloc_.destroy(alloc_.m_);
				alloc_.deallocate(alloc_.m_, 1);
			}
			alloc_.m_ = temp;
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(temp, 1);
			throw;
		}
		#endif
	#else // _MSL_NO_REFCOUNT_STRING
		pointer temp = alloc_.allocate(recommend(nlen) + 1);
		if (data_ != 0)
			traits::copy(temp, data_, pos);
		if (n2 > 0)
			traits::assign(temp + pos, n2, c);
		if (data_ != 0)
			traits::copy(temp + pos + n2, data_ + pos + xlen, size() - (pos + xlen));
		traits::assign(*(temp + nlen), charT());
		if (data_ != 0)
			alloc_.deallocate(data_, alloc_.m_ + 1);
		data_ = temp;
		alloc_.m_ = recommend(nlen);
		size_ = nlen;
	#ifdef _MSL_DEBUG
		__invalidate_all_iterators();
	#endif
	#endif // _MSL_NO_REFCOUNT_STRING
	}
	else
	{	// must do inplace
	#ifdef _MSL_DEBUG
		__invalidate_on_shrink __s(*this);
	#endif
	#ifndef _MSL_NO_REFCOUNT_STRING
		traits::move(alloc_.m_->data() + pos + n2, alloc_.m_->data() + pos + xlen,
			size() - (pos + xlen));
		if (n2 > 0)
			traits::assign(alloc_.m_->data() + pos, n2, c);
		traits::assign(*(alloc_.m_->data() + nlen), charT());
		alloc_.m_->size_ = nlen;
	#else
		if (data_ != 0)
		{
			traits::move(data_ + pos + n2, data_ + pos + xlen, size() - (pos + xlen));
			if (n2 > 0)
				traits::assign(data_ + pos, n2, c);
			traits::assign(*(data_ + nlen), charT());
			size_ = nlen;
		}
	#endif
	}
	return *this;
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(iterator i1, iterator i2,
	const basic_string& str)
{
#ifdef _MSL_DEBUG
	if (i1 > i2)
		_MSL_DEBUG_ERROR(logic_error, "MSL DEBUG: invalid iterator range given to string::replace");
#endif
	return replace(size_type(i1 - begin()), size_type(i2 - i1), str);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(iterator i1, iterator i2, const charT* s,
	size_type n)
{
#ifdef _MSL_DEBUG
	if (i1 > i2)
		_MSL_DEBUG_ERROR(logic_error, "MSL DEBUG: invalid iterator range given to string::replace");
#endif
	return replace(size_type(i1 - begin()), size_type(i2 - i1), s, n);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(iterator i1, iterator i2, const charT* s)
{
#ifdef _MSL_DEBUG
	if (i1 > i2)
		_MSL_DEBUG_ERROR(logic_error, "MSL DEBUG: invalid iterator range given to string::replace");
#endif
	return replace(size_type(i1 - begin()), size_type(i2 - i1), s);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::replace(iterator i1, iterator i2, size_type n, charT c)
{
#ifdef _MSL_DEBUG
	if (i1 > i2)
		_MSL_DEBUG_ERROR(logic_error, "MSL DEBUG: invalid iterator range given to string::replace");
#endif
	return replace(size_type(i1 - begin()), size_type(i2 - i1), n, c);
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::do_replace(size_type pos, size_type len,
	const_pointer first, const_pointer last, random_access_iterator_tag)
{
	if (pos > size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::replace pos out of range");
		#else
			__msl_error("basic_string::replace pos out of range\n");
		#endif
	size_type xlen = min(len, size() - pos);
	size_type rlen = size_type(last - first);
	if (rlen > max_size() || size() - xlen > max_size() - rlen)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("basic_string::replace length error");
		#else
			__msl_error("basic_string::replace length error\n");
		#endif
	size_type nlen = size() - xlen + rlen;
#ifdef _MSL_DEBUG
	__invalidate_past_pos __p(*this, pos);
	__invalidate_on_shrink __s(*this);
	__invalidate_on_reallocate __c(*this);
#endif
#ifndef _MSL_NO_REFCOUNT_STRING
	if (!alloc_.m_->is_unique() || nlen > capacity() || first >= __data() && first < __data() + size())
#else
	if (nlen > capacity() || first >= __data() && first < __data() + size())
#endif
	{	// must do with copy
	#ifndef _MSL_NO_REFCOUNT_STRING
		CharArray* temp = alloc_.allocate(1);
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			new (temp) CharArray(alloc_.m_->get_allocator(), nlen);
			traits::copy(temp->data(), alloc_.m_->data(), pos);
			if (rlen > 0)
				traits::copy(temp->data() + pos, first, rlen);
			traits::copy(temp->data() + pos + rlen, alloc_.m_->data() + pos + xlen,
				size() - (pos + xlen));
			traits::assign(*(temp->data() + nlen), charT());
			temp->size_ = nlen;
			alloc_.m_ = alloc_.m_->removeRef();
			if (alloc_.m_ != 0)
			{
				alloc_.destroy(alloc_.m_);
				alloc_.deallocate(alloc_.m_, 1);
			}
			alloc_.m_ = temp;
		#ifdef _MSL_DEBUG
			__invalidate_all_iterators();
		#endif
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			alloc_.deallocate(temp, 1);
			throw;
		}
		#endif
	#else // _MSL_NO_REFCOUNT_STRING
		pointer temp = alloc_.allocate(recommend(nlen) + 1);
		if (data_ != 0)
			traits::copy(temp, data_, pos);
		if (rlen > 0)
			traits::copy(temp + pos, first, rlen);
		if (data_ != 0)
			traits::copy(temp + pos + rlen, data_ + pos + xlen, size() - (pos + xlen));
		traits::assign(*(temp + nlen), charT());
		if (data_ != 0)
			alloc_.deallocate(data_, alloc_.m_ + 1);
		data_ = temp;
		alloc_.m_ = recommend(nlen);
		size_ = nlen;
		#ifdef _MSL_DEBUG
			__invalidate_all_iterators();
		#endif
	#endif // _MSL_NO_REFCOUNT_STRING
	}
	else
	{	// must do inplace
	#ifdef _MSL_DEBUG
		__invalidate_on_shrink __s(*this);
	#endif
	#ifndef _MSL_NO_REFCOUNT_STRING
		traits::move(alloc_.m_->data() + pos + rlen, alloc_.m_->data() + pos + xlen,
			size() - (pos + xlen));
		if (rlen > 0)
			traits::copy(alloc_.m_->data() + pos, first, rlen);
		traits::assign(*(alloc_.m_->data() + nlen), charT());
		alloc_.m_->size_ = nlen;
	#else // _MSL_NO_REFCOUNT_STRING
		if (data_ != 0)
		{
			traits::move(data_ + pos + rlen, data_ + pos + xlen, size() - (pos + xlen));
			if (rlen > 0)
				traits::copy(data_ + pos, first, rlen);
			traits::assign(*(data_ + nlen), charT());
			size_ = nlen;
		}
	#endif // _MSL_NO_REFCOUNT_STRING
	}
	return *this;
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT, traits, Allocator>&
basic_string<charT, traits, Allocator>::do_replace(size_type pos, size_type len,
	pointer first, pointer last, random_access_iterator_tag)
{
	return do_replace(pos, len, static_cast<const_pointer>(first), static_cast<const_pointer>(last), random_access_iterator_tag());
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::copy(charT* s, size_type n, size_type pos) const
{
	if (pos > size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::copy pos out of range");
		#else
			__msl_error("basic_string::copy pos out of range\n");
		#endif
	size_type rlen = min(n, size() - pos);
	traits::copy(s, __data() + pos, rlen);
	return rlen;
}

template<class charT, class traits, class Allocator>
void
basic_string<charT, traits, Allocator>::swap(basic_string<charT,traits,Allocator>& str)
{
	if (this != &str)
	{
	#ifndef _MSL_NO_REFCOUNT_STRING
		_STD::swap(alloc_, str.alloc_);
	#else
		_STD::swap(size_, str.size_);
		_STD::swap(alloc_, str.alloc_);
		_STD::swap(data_, str.data_);
	#endif
	#ifdef _MSL_DEBUG
		iterator::swap(this, &str);
		const_iterator::swap(this, &str);
	#endif
	}
}

template<class charT, class traits, class Allocator>
inline
const charT*
basic_string<charT, traits, Allocator>::c_str() const
{
	return data();
}

template<class charT, class traits, class Allocator>
#ifndef _MSL_NO_REFCOUNT_STRING
inline
#endif
const charT*
basic_string<charT, traits, Allocator>::data() const
{
#ifndef _MSL_NO_REFCOUNT_STRING
	return alloc_.m_->data();
#else
	if (data_ == 0)
	{
		static const charT __nullstring = charT();
		return &__nullstring;
	}
	return data_;
#endif
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::allocator_type
basic_string<charT, traits, Allocator>::get_allocator() const
{
#ifndef _MSL_NO_REFCOUNT_STRING
	return alloc_.m_->get_allocator();
#else
	return alloc_;
#endif
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find(const basic_string& str, size_type pos) const
{
	return find(str.__iterator2pointer(str.begin()), pos, str.size());
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find(const charT* s, size_type pos, size_type n) const
{
	if (pos > size())
		return npos;
	size_type d1 = size() - pos;
	const charT* sn = s + n;
	for (const_iterator p = begin() + difference_type(pos); d1 >= n; ++p, --d1)
	{
		const_iterator p1 = p;
		for (const charT* s1 = s; s1 < sn; ++s1, ++p1)
			if (!traits::eq(*s1, *p1))
				goto loop;
		return static_cast<size_type>(p - begin());
	loop:;
	}
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find(const charT* s, size_type pos) const
{
	return find(s, pos, traits::length(s));
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find (charT c, size_type pos) const
{
	if (pos >= size())
		return npos;
	for (const_iterator p = begin() + difference_type(pos); p < end(); ++p)
		if (traits::eq(c, *p))
			return static_cast<size_type>(p - begin());
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::rfind(const basic_string& str, size_type pos) const
{
	return rfind(str.__iterator2pointer(str.begin()), pos, str.size());
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::rfind(const charT* s, size_type pos, size_type n) const
{
	if (size() < n)
		return npos;
	if (pos > size() - n)
		pos = size() - n;
	const charT* sn = s + n;
	const_iterator p = begin() + difference_type(pos);
	do
	{
		const_iterator p1 = p;
		for (const charT* s1 = s; s1 < sn; ++s1, ++p1)
			if (!traits::eq(*s1, *p1))
				goto loop;
		return static_cast<size_type>(p - begin());
	loop:;
	} while (p > begin() && (--p, true));
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::rfind(const charT* s, size_type pos) const
{
	return rfind(s, pos, traits::length(s));
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::rfind (charT c, size_type pos) const
{
	if (size() < 1)
		return npos;
	if (pos > size() - 1)
		pos = size() - 1;
	const_iterator p = begin() + difference_type(pos);
	do
	{
		if (traits::eq(c, *p))
			return static_cast<size_type>(p - begin());
	} while (p > begin() && (--p, true));
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_of(const basic_string& str,
	size_type pos) const
{
	return find_first_of(str.__iterator2pointer(str.begin()), pos, str.size());
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_of(const charT* s, size_type pos,
	size_type n) const
{
	if (pos >= size() || n == 0)
		return npos;
	for (const_iterator i = begin() + difference_type(pos); i != end(); ++i)
	{
		const charT* j = s;
		for (size_type n1 = 0; n1 < n; ++n1, ++j)
			if (traits::eq(*i, *j))
				return size_type(i - begin());
	}
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_of(const charT* s, size_type pos) const
{
	return find_first_of(s, pos, traits::length(s));
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_of(charT c, size_type pos) const
{
	if (pos >= size())
		return npos;
	for (const_iterator i = begin() + difference_type(pos); i != end(); ++i)
		if (traits::eq(*i, c))
			return size_type(i - begin());
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_of(const basic_string& str,
	size_type pos) const
{
	return find_last_of(str.__iterator2pointer(str.begin()), pos, str.size());
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_of(const charT* s, size_type pos,
	size_type n) const
{
	if (size() == 0 || n == 0)
		return npos;
	if (pos > size() - 1)
		pos = size() - 1;
	for (const_reverse_iterator i = rend() - difference_type(pos + 1); i != rend(); ++i)
	{
		const charT* j = s;
		for (size_type n1 = 0; n1 < n; ++n1, ++j)
			if (traits::eq(*i, *j))
				return size_type(i.base() - begin() - 1);
	}
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_of(const charT* s, size_type pos) const
{
	return find_last_of(s, pos, traits::length(s));
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_of(charT c, size_type pos) const
{
	if (size() == 0)
		return npos;
	if (pos > size() - 1)
		pos = size() - 1;
	for (const_reverse_iterator i = rend() - difference_type(pos + 1); i != rend(); ++i)
		if (traits::eq(*i, c))
			return size_type(i.base() - begin() - 1);
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_not_of(const basic_string& str,
	size_type pos) const
{
	return find_first_not_of(str.__iterator2pointer(str.begin()), pos, str.size());
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_not_of(const charT* s, size_type pos,
	size_type n) const
{
	if (pos >= size())
		return npos;
	if (n == 0)
		return pos;
	for (const_iterator i = begin() + difference_type(pos); i != end(); ++i)
	{
		const charT* j = s;
		for (size_type n1 = 0; n1 < n; ++n1, ++j)
			if (traits::eq(*i, *j))
				goto not_this_one;
		return size_type(i - begin());
	not_this_one:
		;
	}
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_not_of(const charT* s,
	size_type pos) const
{
	return find_first_not_of(s, pos, traits::length(s));
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_first_not_of(charT c, size_type pos) const
{
	if (pos >= size())
		return npos;
	for (const_iterator i = begin() + difference_type(pos); i != end(); ++i)
		if (!traits::eq(*i, c))
			return size_type(i - begin());
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_not_of(const basic_string& str,
	size_type pos) const
{
	return find_last_not_of(str.__iterator2pointer(str.begin()), pos, str.size());
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_not_of(const charT* s, size_type pos,
	size_type n) const
{
	if (size() == 0)
		return npos;
	if (pos > size() - 1)
		pos = size() - 1;
	for (const_reverse_iterator i = rend() - difference_type(pos + 1); i != rend(); ++i)
	{
		const charT* j = s;
		for (size_type n1 = 0; n1 < n; ++n1, ++j)
			if (traits::eq(*i, *j))
				goto not_this_one;
		return size_type(i.base() - begin() - 1);
	not_this_one:
		;
	}
	return npos;
}

template<class charT, class traits, class Allocator>
inline
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_not_of(const charT* s, size_type pos) const
{
	return find_last_not_of(s, pos, traits::length(s));
}

template<class charT, class traits, class Allocator>
typename basic_string<charT, traits, Allocator>::size_type
basic_string<charT, traits, Allocator>::find_last_not_of(charT c, size_type pos) const
{
	if (size() == 0)
		return npos;
	if (pos > size() - 1)
		pos = size() - 1;
	for (const_reverse_iterator i = rend() - difference_type(pos + 1); i != rend(); ++i)
		if (!traits::eq(*i, c))
			return size_type(i.base() - begin() - 1);
	return npos;
}

template<class charT, class traits, class Allocator>
basic_string<charT, traits, Allocator>
basic_string<charT, traits, Allocator>::substr(size_type pos, size_type n) const
{
	if (pos > size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("basic_string::substr pos out of range");
		#else
			__msl_error("basic_string::substr pos out of range\n");
		#endif
	size_type rlen = min(n, size() - pos);
	return basic_string(*this, pos, rlen);
}

template<class charT, class traits, class Allocator>
inline
int
basic_string<charT, traits, Allocator>::compare(const basic_string& str) const
{
	return compare(0, size(), str.__iterator2pointer(str.begin()), str.size());
}

template<class charT, class traits, class Allocator>
inline
int
basic_string<charT, traits, Allocator>::compare(size_type pos1, size_type n1,
	const basic_string& str) const
{
	return compare(pos1, n1, str.__iterator2pointer(str.begin()), str.size());
}

template<class charT, class traits, class Allocator>
int
basic_string<charT, traits, Allocator>::compare(size_type pos1, size_type n1,
	const basic_string& str, size_type pos2, size_type n2) const
{
	if (pos2 > str.size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("string compare: pos > len");
		#else
			__msl_error("string compare: pos > len\n");
		#endif
	return compare(pos1, n1, str.__iterator2pointer(str.begin()) + pos2, min(str.size() - pos2, n2));
}

template<class charT, class traits, class Allocator>
inline
int
basic_string<charT, traits, Allocator>::compare(const charT* s) const
{
	return compare(0, size(), s, traits::length(s));
}

// hh 990126
template<class charT, class traits, class Allocator>
inline
int
basic_string<charT, traits, Allocator>::compare(size_type pos1, size_type n1, const charT* s) const
{
	return compare(pos1, n1, s, traits::length(s));
}

template<class charT, class traits, class Allocator>
int
basic_string<charT, traits, Allocator>::compare(size_type pos1, size_type n1, const charT* s,
	size_type n2) const
{
	if (pos1 > size())
		#ifndef _MSL_NO_EXCEPTIONS
			throw out_of_range("string compare: pos > len");
		#else
			__msl_error("string compare: pos > len\n");
		#endif
	size_type len = min(size() - pos1 , n1);
	size_type rlen = min(len, n2);
	int result = traits::compare(__iterator2pointer(begin()) + pos1, s, rlen);
	if (result == 0)
	{
		if (len < n2)
			return -1;
		if (len == n2)
			return 0;
		return 1;
	}
	return result;
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
          const basic_string<charT,traits,Allocator>& rhs)
{
	return basic_string<charT, traits, Allocator>(lhs).append(rhs);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT,traits,Allocator>
operator+(const charT* lhs,
          const basic_string<charT,traits,Allocator>& rhs)
{
	return basic_string<charT, traits, Allocator>(lhs).append(rhs);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT,traits,Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	return basic_string<charT, traits, Allocator>(1, lhs).append(rhs);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	return basic_string<charT, traits, Allocator>(lhs).append(rhs);
}

template<class charT, class traits, class Allocator>
inline
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs)
{
	return basic_string<charT, traits, Allocator>(lhs).append(1, rhs);
}

template<class charT, class traits, class Allocator>
inline
bool
operator==(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs)
{
	return lhs.size() == rhs.size() && lhs.compare(rhs) == 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator==(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	return rhs.compare(lhs) == 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	return lhs.compare(rhs) == 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator!=(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs)
{
	return lhs.size() != rhs.size() || lhs.compare(rhs) != 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator!=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	return rhs.compare(lhs) != 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator!=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	return lhs.compare(rhs) != 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator< (const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs)
{
	return lhs.compare(rhs) < 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator< (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	return lhs.compare(rhs) < 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator< (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	return rhs.compare(lhs) > 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator> (const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs)
{
	return lhs.compare(rhs) > 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator> (const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	return lhs.compare(rhs) > 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator> (const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	return rhs.compare(lhs) < 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator<=(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs)
{
	return lhs.compare(rhs) <= 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator<=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	return lhs.compare(rhs) <= 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator<=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	return rhs.compare(lhs) >= 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator>=(const basic_string<charT,traits,Allocator>& lhs,
           const basic_string<charT,traits,Allocator>& rhs)
{
	return lhs.compare(rhs) >= 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator>=(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs)
{
	return lhs.compare(rhs) >= 0;
}

template<class charT, class traits, class Allocator>
inline
bool
operator>=(const charT* lhs, const basic_string<charT,traits,Allocator>& rhs)
{
	return rhs.compare(lhs) <= 0;
}

// _lib.string.special_:
template<class charT, class traits, class Allocator>
inline
void
swap(basic_string<charT,traits,Allocator>& lhs, basic_string<charT,traits,Allocator>& rhs)
{
	lhs.swap(rhs);
}

#ifndef _MSL_NO_IO

template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
operator >> (basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator << (basic_ostream<charT, traits>& os, const basic_string<charT,traits,Allocator>& str);

template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str, charT delim);

template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>& is, basic_string<charT,traits,Allocator>& str);

#endif // _MSL_NO_IO

typedef basic_string<char, char_traits<char>, allocator<char> > string;

#ifndef _MSL_NO_WCHART_CPP_SUPPORT
	typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;
#endif

template <class charT>
basic_string<charT>
__literal(const char* s, charT)
{
	basic_string<charT> str;
	while (*s != 0)
		str.push_back(charT(*s++));
	return str;
}

inline
string
__literal(const char* s, char)
{
	return string(s);
}

#ifndef _MSL_NO_CPP_NAMESPACE
	}  // namespace std
#endif

#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT
	#pragma enumsalwaysint reset
#endif

#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT
	#pragma bool reset
#endif

#pragma options align=reset

#endif  // RC_INVOKED

#endif // _STRING

// hh 980908 rewrote
// hh 981220 Added typename to appropriate return types
// hh 990126 Converted from MSIPL flags to _MSL flags
// hh 990126 Corrected standards bug:  compare(pos1, n1, s) was malfunctioning because the
//           default argument for n2 was npos.  It should be traits::length(s).  This requires
//           splitting compare into two signitures.
// hh 990201 Several changes in getline:  erase string as soon as sentry is passed.
//           Removed temp string as it no longer makes sense.
//           Changed to work with sbumpc instead of istreambuf_iterator.  This reduces the
//           look ahead by 1 char which makes getline behave better when the stream is cin.
// hh 990630 Added null_ object to avoid allocations for constructing null strings.
// hh 990727 Added non-refcounted version
// hh 990728 Uninlined member template methods where feasible.
// hh 990826 Added init method that takes pointer.
// hh 991003 Put null_ object in a static class to better synchronize its construction.
// hh 991102 Added pointer versions of do_append, do_assign and do_replace.
// hh 991114 Minor optimization on operator == and !=.
// hh 000127 Added a mutex lock to addRef.
// hh 000127 Modified copy constructor to bring in line with "ready" DR #42.
// hh 000130 Installed _MSL_NO_LOCALE
// hh 000606 Rewrote find and rfind.  Corrected border cases.
// hh 001011 Moved implementation of char_traits to inside of class declaration
// hh 001011 Fixed typename bug in getline
// hh 001107 Fixed bug in char_traits<charT>::move
// hh 001127 Fixed bug where allocator was used by max_size() from constructors before being created
// hh 001207 Added pop_back
// hh 010125 Changed mutex.h to msl_mutex
// hh 010301 Protected min and max from macro abuse.
// hh 010308 Changed catch (bad_alloc) to catch (...) in several places
// hh 010314 Qualified internal calls with std::
// hh 010402 Removed 68K CMF support
// hh 010425 Moved extractor definitions to istream
// hh 010425 Moved inserter definitions to ostream
// hh 010721 Modified do_assign to check for self assignment
// hh 010727 Fixed typename bug
// hh 010727 Protected dependence on <msl_mutex>
// hh 010802 More typename fixes
// hh 011002 Adjusted find_first_not_of to return pos for 0-length target
// hh 011002 Moved fpos to here from <ios>
// hh 020320 Fixed bug in reserve, not refcounted version, when operating on empty string
