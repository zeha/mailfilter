/* Metrowerks Standard Library
 * Copyright © 1995-2002 Metrowerks Corporation.  All rights reserved.
 *
 * $Date: 2002/10/03 22:46:10 $ 
 * $Revision: 1.4 $ 
 */

// tree

#ifndef _TREE
#define _TREE

// WARNING
//
// tree is a non-standard, non-portable header and container.
//
// WARNING
//
//	__tree serves as the implementation of map, multimap, set and multiset.  The
//	node insertion and removal routines are based on algorithms presented in
//	Cormen, Leiserson, and Rivest, Introduction to Algorithms (MIT Press, 1990).
//	Modifications to these algorithms include:
//
//	1.	Sentinel nodes are not used.  The algorithm has been modified to have
//		Sentinel nodes modled by null pointers in the leaf nodes.  Nodes represented
//		in this fashion have a color of black, and are never explicitly referenced.
//
//	2.	Point 1 is especially important in the balancing portion of the node delete
//		routine.  Here a null node is required to know it's parent and whether it is
//		a left child or right child.  This is fixed up by storing the parent of the
//		null node (instead of the null node), and a bool representing whether it is
//		a left child or right child.
//
//	3.	The orignal node delete routine called for copying one node into another.
//		This would cause non-standard behavior, so instead pointers are fixed up
//		to achieve the same effect.
//
//	4.	The "RB-Delete" and "RB-Delete-Fixup" routines are implemented as one
//		routine here:  "balance_erase".

/*  __tree synopsis

This is normally not a client level header.  But in some circumstances,
using __tree directly is more convenient than map/set.  Especially
when you need to find/erase on a key that is only part of the value_type
(see map for an example).

namespace std
{

template <class T, class Compare, class Allocator>
class __tree
{
public:
	//  types:
	typedef T                                     value_type;
	typedef Compare                               value_compare;
	typedef Allocator                             allocator_type;
	typedef typename Allocator::reference         reference;
	typedef typename Allocator::const_reference   const_reference;
	typedef typename Allocator::size_type         size_type;
	typedef typename Allocator::difference_type   difference_type;
	typedef typename Allocator::pointer           pointer;
	typedef typename Allocator::const_pointer     const_pointer;

	class                                         iterator;        // bidirectional
	class                                         const_iterator;  // bidirectional

	typedef std::reverse_iterator<iterator>       reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	//  lib.set.cons construct/copy/destroy:
	__tree();
	__tree(const Compare& comp, const Allocator& a);
	template <class InputIterator>
		__tree(InputIterator first, InputIterator last, bool multi,
		       const Compare& comp, const Allocator& a);
	__tree(const __tree& x);
	~__tree();
	__tree& operator=(const __tree& x);

	allocator_type get_allocator() const;
	size_type      max_size() const;

	size_type     size() const;
	bool          empty() const;

	iterator               begin();
	const_iterator         begin() const;
	iterator               end();
	const_iterator         end() const;

	reverse_iterator       rbegin();
	const_reverse_iterator rbegin() const;
	reverse_iterator       rend();
	const_reverse_iterator rend() const;

	template <class Key, class V> T& find_or_insert(const Key& key);
	pair<iterator,bool> insert_one(const value_type& x);
	iterator            insert_multi(const value_type& x);
	iterator            insert_one(iterator position, const value_type& x);
	const_iterator      insert_one(const_iterator position, const value_type& x)
	iterator            insert_multi(iterator position, const value_type& x);
	const_iterator      insert_multi(const_iterator position, const value_type& x)
	template <class InputIterator> void insert_one(InputIterator first, InputIterator last);
	template <class InputIterator> void insert_multi(InputIterator first, InputIterator last);

	void      erase(iterator position);
	void      erase(const_iterator position)
	template <class Key> size_type erase_one(const Key& x);
	template <class Key> size_type erase_multi(const Key& x);
	void      erase(iterator first, iterator last);
	void      erase(const_iterator first, const_iterator last)
	void clear();

	void swap(__tree& x);

	value_compare value_comp() const;

	template <class Key> iterator       find(const Key& x);
	template <class Key> const_iterator find(const Key& x) const;
	template <class Key> size_type count_one(const Key& x) const;
	template <class Key> size_type count_multi(const Key& x) const;

	template <class Key> iterator       lower_bound(const Key& x);
	template <class Key> const_iterator lower_bound(const Key& x) const;
	template <class Key> iterator       upper_bound(const Key& x);
	template <class Key> const_iterator upper_bound(const Key& x) const;
	template <class Key> pair<iterator, iterator>             equal_range(const Key& x);
	template <class Key> pair<const_iterator, const_iterator> equal_range(const Key& x) const;

	bool invariants() const;
};

}  // std
*/

#include <mslconfig>
#include <msl_utility>
#include <memory>
#include <stdexcept>
#include <iterator>
#include <algorithm>

// hh 981203 **** WARNING ****  __pointer_plus_bit is not standard.
// It is used in the implementation of __tree.  It compacts a bool
// and a pointer into the space of a pointer.  The pointer must refer
// to memory with an alignment of 2 or more bytes.
// Use of this optimization can be turned off in <mslconfig> with the
// _Inhibit_Optimize_RB_bit flag.

#if (__option(structalignment)==3  || __option(structalignment) == 8) && !defined(_Inhibit_Optimize_RB_bit)
	#define _Inhibit_Optimize_RB_bit
#endif

#pragma options align=native

#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT
	#if _MSL_FORCE_ENUMS_ALWAYS_INT
		#pragma enumsalwaysint on
	#else
		#pragma enumsalwaysint off
	#endif
#endif

#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT
	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT
		#pragma bool on
	#else
		#pragma bool off
	#endif
#endif

#ifdef min
#undef min
#endif

#ifdef max
#undef max
#endif

#ifndef _MSL_NO_CPP_NAMESPACE
	namespace std {
#endif

template <class T>
class __pointer_plus_bit
{
public:
	__pointer_plus_bit(T* ptr = 0);
	__pointer_plus_bit& operator = (const __pointer_plus_bit& x);
	__pointer_plus_bit& operator = (T* x);
	operator T* () const;
	bool bit() const;
	void bit(bool b);
	T* operator -> () const;
private:
	T* ptr_;

	__pointer_plus_bit(const __pointer_plus_bit&); // not defined
};

template <class T>
inline
__pointer_plus_bit<T>::__pointer_plus_bit(T* ptr)
	: ptr_(ptr)
{
}

template <class T>
inline
__pointer_plus_bit<T>&
__pointer_plus_bit<T>::operator = (const __pointer_plus_bit& x)
{
	ptr_ = (T*)(((size_t)x.ptr_ & ~1) | ((size_t)ptr_ & 1));
	return *this;
}

template <class T>
inline
__pointer_plus_bit<T>&
__pointer_plus_bit<T>::operator = (T* x)
{
	ptr_ = (T*)((size_t)x | ((size_t)ptr_ & 1));
	return *this;
}

template <class T>
inline
__pointer_plus_bit<T>::operator T* () const
{
	return (T*)((size_t)ptr_ & ~1);
}

template <class T>
inline
bool
__pointer_plus_bit<T>::bit() const
{
	return bool((size_t)ptr_ & 1);
}

template <class T>
inline
void
__pointer_plus_bit<T>::bit(bool b)
{
	if (b)
		ptr_ = (T*)((size_t)ptr_ | 1);
	else
		ptr_ = (T*)((size_t)ptr_ & ~1);
}

template <class T>
inline
T*
__pointer_plus_bit<T>::operator -> () const
{
	return (T*)((size_t)ptr_ & ~1);
}

template <bool b>
class __red_black_tree
{
protected:

	enum Color {black, red};

	struct node_base;
	
	struct anchor
	{
		node_base* left_;

		anchor(node_base* left = 0) : left_(left) {}
	};

	#ifndef _Inhibit_Optimize_RB_bit

		struct node_base
			: public anchor
		{
			node_base* right_;
			__pointer_plus_bit<node_base> parent_;

			node_base(node_base* left = 0, node_base* right = 0, node_base* parent = 0) : anchor(left), right_(right), parent_(parent) {}
			Color color() const {return Color(parent_.bit());}
			void set_color(Color c) {parent_.bit(bool(c));}
		};

	#else

		struct node_base
			: public anchor
		{
			node_base* right_;
			node_base* parent_;
			Color color_;

			node_base(node_base* left = 0, node_base* right = 0, node_base* parent = 0) : anchor(left), right_(right), parent_(parent) {}
			Color color() const {return color_;}
			void set_color(Color c) {color_ = c;}
		};

	#endif

	static node_base* leftmost(node_base* x);
	static node_base* rightmost(node_base* x);
	static void increment(const node_base*& x);
	static void decrement(const node_base*& x);
	static void balance_insert(node_base* x, node_base* root);
	static void balance_erase(node_base* z, node_base* root);
private:
	static void rotate_left(node_base* x, node_base*& root);
	static void rotate_right(node_base* x, node_base*& root);
};

template <bool b>
inline
typename __red_black_tree<b>::node_base*
__red_black_tree<b>::leftmost(node_base* x)
{
	while (x->left_ != 0)
		x = x->left_;
	return x;
}

template <bool b>
inline
typename __red_black_tree<b>::node_base*
__red_black_tree<b>::rightmost(node_base* x)
{
	while (x->right_ != 0)
		x = x->right_;
	return x;
}

template <bool b>
void
__red_black_tree<b>::increment(const node_base*& x)
{
	if (x->right_ != 0)
		x = leftmost(x->right_);
	else
	{
		while (x != x->parent_->left_)
			x = x->parent_;
		x = x->parent_;
	}
}

template <bool b>
void
__red_black_tree<b>::decrement(const node_base*& x)
{
	if (x->left_ != 0)
		x = rightmost(x->left_);
	else
	{
		while (x == x->parent_->left_)
			x = x->parent_;
		x = x->parent_;
	}
}

template <bool b>
void
__red_black_tree<b>::balance_insert(node_base* x, node_base* root)
{
	x->set_color(red);
	while (x != root && x->parent_->color() == red)
	{
		if (x->parent_ == x->parent_->parent_->left_)
		{
			node_base* y = x->parent_->parent_->right_;
			if (y != 0 && y->color() == red)
			{
				x->parent_->set_color(black);
				y->set_color(black);
				x = x->parent_->parent_;
				x->set_color(red);
			}
			else
			{
				if (x == x->parent_->right_)
				{
					x = x->parent_;
					rotate_left(x, root);
				}
				x->parent_->set_color(black);
				x->parent_->parent_->set_color(red);
				rotate_right(x->parent_->parent_, root);
			}
		}
		else
		{
			node_base* y = x->parent_->parent_->left_;
			if (y != 0 && y->color() == red)
			{
				x->parent_->set_color(black);
				y->set_color(black);
				x = x->parent_->parent_;
				x->set_color(red);
			}
			else
			{
				if (x == x->parent_->left_)
				{
					x = x->parent_;
					rotate_right(x, root);
				}
				x->parent_->set_color(black);
				x->parent_->parent_->set_color(red);
				rotate_left(x->parent_->parent_, root);
			}
		}
	}
	root->set_color(black);
}

template <bool b>
void
__red_black_tree<b>::balance_erase(node_base* z, node_base* root)
{
	// Remove z from tree
	node_base* y = z;
	if (z->left_ != 0 && z->right_ != 0)
		increment((const node_base*&)y);
	node_base* x = y->left_ != 0 ? y->left_ : y->right_;
	node_base* x_parent = y->parent_;
	if (x != 0)
		x->parent_ = x_parent;
	bool x_is_left_child;
	if (y == y->parent_->left_)
	{
		y->parent_->left_ = x;
		x_is_left_child = true;
	}
	else
	{
		y->parent_->right_ = x;
		x_is_left_child = false;
	}
	bool removed_black = y->color() == black;
	if (y != z)
	{	// Replace z with y
		y->parent_ = z->parent_;
		if (z == y->parent_->left_)
			y->parent_->left_ = y;
		else
			y->parent_->right_ = y;
		y->left_ = z->left_;
		if (y->left_ != 0)
			y->left_->parent_ = y;
		else
			x_parent = y;
		y->right_ = z->right_;
		if (y->right_ != 0)
			y->right_->parent_ = y;
		else
			x_parent = y;
		y->set_color(z->color());
		if (root == z)
			root = y;
	}
	else if (x == 0 && z == root)
		removed_black = false; // removing last node, don't balance
	if (removed_black)
	{	// Balance tree
		while (x != root && (x == 0 || x->color() == black))
		{
			if (x_is_left_child)
			{
				node_base* w = x_parent->right_;
				if (w->color() == red)
				{
					w->set_color(black);
					x_parent->set_color(red);
					rotate_left(x_parent, root);
					w = x_parent->right_;
				}
				if ((w->left_  == 0 || w->left_->color()  == black) &&
					(w->right_ == 0 || w->right_->color() == black))
				{
					w->set_color(red);
					x = x_parent;
					x_parent = x->parent_;
					x_is_left_child = x == x_parent->left_;
				}
				else
				{
					if (w->right_ == 0 || w->right_->color() == black)
					{
						w->left_->set_color(black);
						w->set_color(red);
						rotate_right(w, root);
						w = x_parent->right_;
					}
					w->set_color(x_parent->color());
					x_parent->set_color(black);
					w->right_->set_color(black);
					rotate_left(x_parent, root);
					x = root;
				}
			}
			else
			{
				node_base* w = x_parent->left_;
				if (w->color() == red)
				{
					w->set_color(black);
					x_parent->set_color(red);
					rotate_right(x_parent, root);
					w = x_parent->left_;
				}
				if ((w->left_  == 0 || w->left_->color()  == black) &&
					(w->right_ == 0 || w->right_->color() == black))
				{
					w->set_color(red);
					x = x_parent;
					x_parent = x->parent_;
					x_is_left_child = x == x_parent->left_;
				}
				else
				{
					if (w->left_ == 0 || w->left_->color() == black)
					{
						w->right_->set_color(black);
						w->set_color(red);
						rotate_left(w, root);
						w = x_parent->left_;
					}
					w->set_color(x_parent->color());
					x_parent->set_color(black);
					w->left_->set_color(black);
					rotate_right(x_parent, root);
					x = root;
				}
			}
		}
		if (x != 0)
			x->set_color(black);
	}
}

template <bool b>
void
__red_black_tree<b>::rotate_left(node_base* x, node_base*& root)
{
	node_base* y = x->right_;
	if (root == x)
		root = y;
	x->right_ = y->left_;
	if (y->left_ != 0)
		y->left_->parent_ = x;
	y->parent_ = x->parent_;
	if (x == x->parent_->left_)
		x->parent_->left_ = y;
	else
		x->parent_->right_ = y;
	y->left_ = x;
	x->parent_ = y;
}

template <bool b>
void
__red_black_tree<b>::rotate_right(node_base* x, node_base*& root)
{
	node_base* y = x->left_;
	if (root == x)
		root = y;
	x->left_ = y->right_;
	if (y->right_ != 0)
		y->right_->parent_ = x;
	y->parent_ = x->parent_;
	if (x == x->parent_->left_)
		x->parent_->left_ = y;
	else
		x->parent_->right_ = y;
	y->right_ = x;
	x->parent_ = y;
}

template <class T, class Compare, class Allocator>
class __tree
	: private __red_black_tree<true>
{
	typedef __red_black_tree<true> base;
public:
	//  types:
	typedef T                                     value_type;
	typedef Compare                               value_compare;
	typedef Allocator                             allocator_type;
	typedef typename Allocator::reference         reference;
	typedef typename Allocator::const_reference   const_reference;
	typedef typename Allocator::size_type         size_type;
	typedef typename Allocator::difference_type   difference_type;
	typedef typename Allocator::pointer           pointer;
	typedef typename Allocator::const_pointer     const_pointer;

private:
	typedef typename base::anchor anchor;
	typedef typename base::node_base node_base;

	struct node
		: public node_base
	{
		value_type data_;
	private:
		node();  // hh 990826
	};

	typedef typename allocator_type::rebind<node>::other node_allocator_type;
	typedef typename node_allocator_type::pointer node_pointer;
	typedef typename node_allocator_type::const_pointer const_node_pointer;

public:

#ifdef _Inhibit_Optimize_RB_bit

	struct debug_view
	{
		debug_view* left_;
		debug_view* right_;
		debug_view* parent_;
		Color color_;
		value_type data_;
	};

#else

	struct debug_view
	{
		debug_view* left_;
		debug_view* right_;
		__pointer_plus_bit<debug_view> parent_;
		value_type data_;
	};

#endif

	template <bool is_const>
	class __generic_iterator
	{
	public:
		typedef typename __tree::value_type       value_type;
		typedef typename __tree::difference_type  difference_type;
		typedef typename Metrowerks::select<is_const, typename __tree::const_pointer,
		                                              typename __tree::pointer>::type pointer;
		typedef typename Metrowerks::select<is_const, typename __tree::const_reference,
		                                              typename __tree::reference>::type reference;
		typedef bidirectional_iterator_tag        iterator_category;
		
		__generic_iterator() {}
		__generic_iterator(const __generic_iterator<false>& i) : ptr_(i.ptr_) {}
		reference operator * () const {return ptr_->data_;}
		pointer operator -> () const  {return &ptr_->data_;}
		__generic_iterator& operator ++ () {increment((const node_base*&)ptr_); return *this;}
		__generic_iterator operator ++ (int) {__generic_iterator tmp(*this); ++(*this); return tmp;}
		__generic_iterator& operator -- () {decrement((const node_base*&)ptr_); return *this;}
		__generic_iterator operator -- (int) {__generic_iterator tmp(*this); --(*this); return tmp;}
		friend bool operator ==(const __generic_iterator& x, const __generic_iterator& y) {return x.ptr_ == y.ptr_;}
		friend bool operator !=(const __generic_iterator& x, const __generic_iterator& y) {return x.ptr_ != y.ptr_;}
	private:
		typedef typename Metrowerks::select<is_const, typename node_allocator_type::const_pointer,
		                                              typename node_allocator_type::pointer>::type node_pointer;

		node_pointer ptr_;

		explicit __generic_iterator(node_pointer n) : ptr_(n) {}

		friend class __generic_iterator<true>;
		friend class __tree;
	};

	friend class __generic_iterator<false>;
	friend class __generic_iterator<true>;

#ifndef _MSL_DEBUG
	typedef __generic_iterator<false> iterator;
	typedef __generic_iterator<true>  const_iterator;

	static node_pointer       __iterator2pointer(iterator& i) {return i.ptr_;}
	static const_node_pointer __iterator2pointer(const_iterator& i) {return i.ptr_;}
	static iterator       __pointer2iterator(node_pointer p)       {return iterator(p);}
	static const_iterator __pointer2iterator(const_node_pointer p) {return const_iterator(p);}
#else  // _MSL_DEBUG
private:
	typedef __generic_iterator<false> __uncheck_iterator;
	typedef __generic_iterator<true>  __uncheck_const_iterator;
public:
	typedef __debug_iterator<__tree, __uncheck_iterator>        iterator;
	typedef __debug_iterator<__tree, __uncheck_const_iterator>  const_iterator;
private:
	void __invalidate_iterator(const iterator& i)
	{
		if (iterator_list<iterator>())
			iterator_list<iterator>()->remove(bind2nd(equal_to<__uncheck_iterator>(), i.base()));
		if (iterator_list<const_iterator>())
			iterator_list<const_iterator>()->remove(bind2nd(equal_to<__uncheck_const_iterator>(), i.base()));
	}

	node_pointer __iterator2pointer(iterator& i)
	{
		if (i.owner_ != this)
			_MSL_DEBUG_ERROR(logic_error, "MSL DEBUG: invalid iterator given to tree");
		return i.base().ptr_;
	}

	const_node_pointer __iterator2pointer(const_iterator& i)
	{
		if (i.owner_ != this)
			_MSL_DEBUG_ERROR(logic_error, "MSL DEBUG: invalid iterator given to tree");
		return i.base().ptr_;
	}
	iterator __pointer2iterator(node_pointer p) {return iterator(this, __uncheck_iterator(p));}
	const_iterator __pointer2iterator(const_node_pointer p) const {return const_iterator(this, __uncheck_const_iterator(p));}
public:
#endif  // _MSL_DEBUG

	typedef _STD::reverse_iterator<iterator>       reverse_iterator;
	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;

	//  lib.set.cons construct/copy/destroy:
	__tree();
	__tree(const Compare& comp, const Allocator& a);
#ifndef _MSL_NO_MEMBER_TEMPLATE
	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
		template <class InputIterator>
			__tree(InputIterator first, InputIterator last, bool multi,
				const Compare& comp, const Allocator& a);
	#else
		template <class InputIterator>
			__tree(InputIterator first, InputIterator last, bool multi,
				const Compare& comp, const Allocator& a)
				: alloc_(a, 0),
				  node_alloc_(a),
				  comp_(comp)
			{
				front() = (node*)&tail();
				#ifndef _MSL_NO_EXCEPTIONS
				try
				{
				#endif
					if (multi)
						insert_multi(first, last);
					else
						insert_one(first, last);
				#ifndef _MSL_NO_EXCEPTIONS
				}
				catch (...)
				{
					if (root() != 0)
						destroy(root());
					throw;
				}
				#endif
			}
	#endif
#else
	__tree(const_iterator first, const_iterator last, bool multi,
		const Compare& comp, const Allocator& a);
	__tree(const value_type* first, const value_type* last, bool multi,
		const Compare& comp, const Allocator& a);
#endif
	__tree(const __tree& x);
	~__tree();
	__tree& operator = (const __tree& x);
	allocator_type get_allocator() const;

	//  iterators:
	iterator               begin();
	const_iterator         begin() const;
	iterator               end();
	const_iterator         end() const;

#ifdef _MSL_DEBUG
private:
	__uncheck_iterator       __uncheck_begin()       {return __uncheck_iterator(front());}
	__uncheck_const_iterator __uncheck_begin() const {return __uncheck_const_iterator(front());}
	__uncheck_iterator       __uncheck_end()         {return __uncheck_iterator((node*)&tail());}
	__uncheck_const_iterator __uncheck_end() const   {return __uncheck_const_iterator((const node*)&tail());}
public:
#endif

	reverse_iterator       rbegin();
	const_reverse_iterator rbegin() const;
	reverse_iterator       rend();
	const_reverse_iterator rend() const;

	//  capacity:
	bool          empty() const;
	size_type     size() const;
	size_type     max_size() const;

	//  modifiers:
#if !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_MSL_MUST_INLINE_MEMBER_TEMPLATE)
	template <class Key, class V> T& find_or_insert(const Key& key);
#endif
	pair<iterator,bool> insert_one(const value_type& x);
	iterator            insert_multi(const value_type& x);
	iterator            insert_one(iterator position, const value_type& x);
	const_iterator      insert_one(const_iterator position, const value_type& x)
	                    {return insert_one(__pointer2iterator(const_cast<node_pointer>(__iterator2pointer(position))), x);}
	iterator            insert_multi(iterator position, const value_type& x);
	const_iterator      insert_multi(const_iterator position, const value_type& x)
	                    {return insert_multi(__pointer2iterator(const_cast<node_pointer>(__iterator2pointer(position))), x);}
#ifndef _MSL_NO_MEMBER_TEMPLATE
	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE
		template <class InputIterator> void insert_one(InputIterator first, InputIterator last);
		template <class InputIterator> void insert_multi(InputIterator first, InputIterator last);
	#else

		template <class InputIterator>
		inline
		void
		insert_one(InputIterator first, InputIterator last)
		{
			for (; first != last; ++first)
				insert_one(end(), *first);
		}

		template <class InputIterator>
		inline
		void
		insert_multi(InputIterator first, InputIterator last)
		{
			for (; first != last; ++first)
				insert_multi(end(), *first);
		}

	#endif
#else
	void insert_one(const_iterator first, const_iterator last);
	void insert_one(const value_type* first, const value_type* last);
	void insert_multi(const_iterator first, const_iterator last);
	void insert_multi(const value_type* first, const value_type* last);
#endif

	void      erase(iterator position);
	void      erase(const_iterator position)
	          {erase(__pointer2iterator(const_cast<node_pointer>(__iterator2pointer(position))));}
#if !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_MSL_MUST_INLINE_MEMBER_TEMPLATE)
	template <class Key> size_type erase_one(const Key& x);
	template <class Key> size_type erase_multi(const Key& x);
#else
	size_type erase_one(const value_type& x);
	size_type erase_multi(const value_type& x);
#endif
	void      erase(iterator first, iterator last);
	void      erase(const_iterator first, const_iterator last)
	          {erase(__pointer2iterator(const_cast<node_pointer>(__iterator2pointer(first))),
	                 __pointer2iterator(const_cast<node_pointer>(__iterator2pointer(last))));}
	void swap(__tree& x);
	void clear();

	//  observers:
	value_compare value_comp() const;

#if !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_MSL_MUST_INLINE_MEMBER_TEMPLATE)
	//  set operations:
	template <class Key> iterator       find(const Key& x);
	template <class Key> const_iterator find(const Key& x) const;
	template <class Key> size_type count_one(const Key& x) const;
	template <class Key> size_type count_multi(const Key& x) const;

	template <class Key> iterator       lower_bound(const Key& x);
	template <class Key> const_iterator lower_bound(const Key& x) const;
	template <class Key> iterator       upper_bound(const Key& x);
	template <class Key> const_iterator upper_bound(const Key& x) const;
	template <class Key> pair<iterator, iterator>             equal_range(const Key& x);
	template <class Key> pair<const_iterator, const_iterator> equal_range(const Key& x) const;
#else
	//  set operations:
	iterator       find(const value_type& x);
	const_iterator find(const value_type& x) const;
	size_type count_one(const value_type& x) const;
	size_type count_multi(const value_type& x) const;

	iterator       lower_bound(const value_type& x);
	const_iterator lower_bound(const value_type& x) const;
	iterator       upper_bound(const value_type& x);
	const_iterator upper_bound(const value_type& x) const;
	pair<iterator, iterator>             equal_range(const value_type& x);
	pair<const_iterator, const_iterator> equal_range(const value_type& x) const;
#endif

	bool invariants() const;
private:
	Metrowerks::compressed_pair<allocator_type, size_type>   alloc_;
	Metrowerks::compressed_pair<node_allocator_type, anchor> node_alloc_;
	Metrowerks::compressed_pair<value_compare, node*>        comp_;

	      allocator_type& alloc()        {return alloc_.first();}
	const allocator_type& alloc() const  {return alloc_.first();}
	      size_type&      sz()           {return alloc_.second();}
	const size_type&      sz() const     {return alloc_.second();}

	      node_allocator_type& node_alloc()       {return node_alloc_.first();}
	const node_allocator_type& node_alloc() const {return node_alloc_.first();}
	      anchor&              tail()             {return node_alloc_.second();}
	const anchor&              tail()       const {return node_alloc_.second();}

	      value_compare& comp()        {return comp_.first();}
	const value_compare& comp() const  {return comp_.first();}
	node*&               front()       {return comp_.second();}
	node*                front() const {return comp_.second();}

	int count_black(node_base* x) const;

	node* root() const;
	node*& root();
	void destroy(node* p);
	node* copy(const node* x);
	node* insert_node_at(node* p, bool leftchild, bool is_leftmost, const value_type& x);
#ifdef _MSL_DEBUG
	pair<iterator*, const_iterator*> iterator_list_;

	iterator*&       iterator_list(iterator*)       {return iterator_list_.first;}
	const_iterator*& iterator_list(const_iterator*) {return iterator_list_.second;}
	template <class Iterator>
	Iterator*& iterator_list() {return iterator_list((Iterator*)0);}

	friend class iterator;
	friend class const_iterator;
#endif
};

// Implementation

template <class T, class Compare, class Allocator>
bool
__tree<T, Compare, Allocator>::invariants() const
{
	if (sz() != distance(begin(), end()))
		return false;
	if (sz() != distance(rbegin(), rend()))
		return false;
#ifndef _Inhibit_Optimize_RB_bit
	if ((size_t)&tail() & 1)
		return false;
#endif
	if (sz() == 0)
	{
		if (root() != 0)
			return false;
		if (front() != (const node*)&tail())
			return false;
	}
	else
	{
		if (root() == 0)
			return false;
		if (root()->color() != black)
			return false;
		if (root()->parent_ != (const node*)&tail())
			return false;
		if (front() != (node*)leftmost(root()))
			return false;
		if (count_black(root()) < 0)
			return false;
	}
	return true;
}

template <class T, class Compare, class Allocator>
__tree<T, Compare, Allocator>::__tree()
	: alloc_(0)
{
	front() = (node*)&tail();
}

template <class T, class Compare, class Allocator>
__tree<T, Compare, Allocator>::__tree(const Compare& comp, const Allocator& a)
	: alloc_(a, 0),
#ifndef _MSL_NO_MEMBER_TEMPLATE
#if __option(old_argmatch)
	  node_alloc_(node_allocator_type(a)),
#else
	  node_alloc_(a),
#endif
#endif
	  comp_(comp)
{
	front() = (node*)&tail();
}

#ifndef _MSL_NO_MEMBER_TEMPLATE
	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE

		template <class T, class Compare, class Allocator>
		template <class InputIterator>
		__tree<T, Compare, Allocator>::__tree(InputIterator first, InputIterator last, bool multi,
			const Compare& comp, const Allocator& a)
			: alloc_(a, 0),
		#if __option(old_argmatch)
			  node_alloc_(node_allocator_type(a)),
		#else
			  node_alloc_(a),
		#endif
			  comp_(comp)
		{
			front() = (node*)&tail();
			#ifndef _MSL_NO_EXCEPTIONS
			try
			{
			#endif
				if (multi)
					insert_multi(first, last);
				else
					insert_one(first, last);
			#ifndef _MSL_NO_EXCEPTIONS
			}
			catch (...)
			{
				if (root() != 0)
					destroy(root());
				throw;
			}
			#endif
		}

	#endif
#else

	template <class T, class Compare, class Allocator>
	__tree<T, Compare, Allocator>::__tree(const_iterator first, const_iterator last,
		bool multi, const Compare& comp, const Allocator& a)
		: alloc_(a, 0),
		  comp_(comp)
	{
		front() = (node*)&tail();
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			if (multi)
				insert_multi(first, last);
			else
				insert_one(first, last);
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			if (root() != 0)
				destroy(root());
			throw;
		}
		#endif
	}

	template <class T, class Compare, class Allocator>
	__tree<T, Compare, Allocator>::__tree(const value_type* first, const value_type* last,
		bool multi, const Compare& comp, const Allocator& a)
		: alloc_(a, 0),
		  comp_(comp)
	{
		front() = (node*)&tail();
		#ifndef _MSL_NO_EXCEPTIONS
		try
		{
		#endif
			if (multi)
				insert_multi(first, last);
			else
				insert_one(first, last);
		#ifndef _MSL_NO_EXCEPTIONS
		}
		catch (...)
		{
			if (root() != 0)
				destroy(root());
			throw;
		}
		#endif
	}

#endif

template <class T, class Compare, class Allocator>
__tree<T, Compare, Allocator>::__tree(const __tree& x)
	: alloc_(x.alloc_),
	  node_alloc_(x.node_alloc_),
	  comp_(x.comp_)
{
	if (x.root() != 0)
	{
		root() = copy(x.root());
		root()->parent_ = (node_base*)&tail();
		front() = (node*)leftmost(root());
	}
	else
		front() = (node*)&tail();
}

template <class T, class Compare, class Allocator>
inline
__tree<T, Compare, Allocator>::~__tree()
{
	if (root() != 0)
		destroy(root());
}

template <class T, class Compare, class Allocator>
__tree<T, Compare, Allocator>&
__tree<T, Compare, Allocator>::operator = (const __tree& x)
{
	if (this == &x)
		return *this;
	clear();
	if (x.root() != 0)
	{
		root() = copy(x.root());
		root()->parent_ = (node_base*)&tail();
	}
	sz() = x.sz();
	comp() = x.comp();
	if (root() != 0)
		front() = (node*)leftmost(root());
	else
		front() = (node*)&tail();
	return *this;
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::allocator_type
__tree<T, Compare, Allocator>::get_allocator() const
{
	return alloc();
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::iterator
__tree<T, Compare, Allocator>::begin()
{
	return __pointer2iterator(front());
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::const_iterator
__tree<T, Compare, Allocator>::begin() const
{
	return __pointer2iterator(front());
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::iterator
__tree<T, Compare, Allocator>::end()
{
	return __pointer2iterator((node*)&tail());
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::const_iterator
__tree<T, Compare, Allocator>::end() const
{
	return __pointer2iterator((const node*)&tail());
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::reverse_iterator
__tree<T, Compare, Allocator>::rbegin()
{
	return reverse_iterator(end());
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::const_reverse_iterator
__tree<T, Compare, Allocator>::rbegin() const
{
	return const_reverse_iterator(end());
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::reverse_iterator
__tree<T, Compare, Allocator>::rend()
{
	return reverse_iterator(begin());
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::const_reverse_iterator
__tree<T, Compare, Allocator>::rend() const
{
	return const_reverse_iterator(begin());
}

template <class T, class Compare, class Allocator>
inline
bool
__tree<T, Compare, Allocator>::empty() const
{
	return sz() == 0;
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::size_type
__tree<T, Compare, Allocator>::size() const
{
	return sz();
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::size_type
__tree<T, Compare, Allocator>::max_size() const
{
	return numeric_limits<size_type>::max();
}

#if !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_MSL_MUST_INLINE_MEMBER_TEMPLATE)

	// hh 990820
	template <class T, class Compare, class Allocator>
	template <class Key, class V>
	T&
	__tree<T, Compare, Allocator>::find_or_insert(const Key& key)
	{
		node* prev = 0;
		node* p = (node*)&tail();
		node* n = root();
		bool leftchild = true;
		bool is_leftmost = true;
		while (n != 0)
		{
			p = n;
			if (comp()(key, n->data_))
			{
				n = (node*)n->left_;
				leftchild = true;
			}
			else
			{
				prev = p;
				n = (node*)n->right_;
				leftchild = false;
				is_leftmost = false;
			}
		}
		if (prev == 0 || comp()(prev->data_, key))
			return insert_node_at(p, leftchild, is_leftmost, value_type(key, V()))->data_;
		return prev->data_;
	}

#endif

template <class T, class Compare, class Allocator>
pair<typename __tree<T, Compare, Allocator>::iterator, bool>
__tree<T, Compare, Allocator>::insert_one(const value_type& x)
{
	node* prev = 0;
	node* p = (node*)&tail();
	node* n = root();
	bool leftchild = true;
	bool is_leftmost = true;
	while (n != 0)
	{
		p = n;
		if (comp()(x, n->data_))
		{
			n = (node*)n->left_;
			leftchild = true;
		}
		else
		{
			prev = p;
			n = (node*)n->right_;
			leftchild = false;
			is_leftmost = false;
		}
	}
	if (prev == 0 || comp()(prev->data_, x))
	{
		n = insert_node_at(p, leftchild, is_leftmost, x);
		return pair<iterator, bool>(__pointer2iterator(n), true);
	}
	return pair<iterator, bool>(__pointer2iterator(prev), false);
}

template <class T, class Compare, class Allocator>
typename __tree<T, Compare, Allocator>::iterator
__tree<T, Compare, Allocator>::insert_multi(const value_type& x)
{
	node* p = (node*)&tail();
	node* n = root();
	bool leftchild = true;
	bool is_leftmost = true;
	while (n != 0)
	{
		p = n;
		if (comp()(x, n->data_))
		{
			n = (node*)n->left_;
			leftchild = true;
		}
		else
		{
			n = (node*)n->right_;
			leftchild = false;
			is_leftmost = false;
		}
	}
	return __pointer2iterator(insert_node_at(p, leftchild, is_leftmost, x));
}

template <class T, class Compare, class Allocator>
typename __tree<T, Compare, Allocator>::iterator
__tree<T, Compare, Allocator>::insert_one(iterator position, const value_type& x)
{
	if (position == end() || comp()(x, *position))  // hh 990820
	{
		iterator before = position;
		if (before == begin() || comp()(*--before, x))
		{
			node* p1 = __iterator2pointer(before);
			node* p2 = __iterator2pointer(position);
			if (p2->left_ == 0)
				return __pointer2iterator(insert_node_at(p2, true, position == begin(), x));
			return __pointer2iterator(insert_node_at(p1, false, false, x));
		}
	}
	else if (comp()(*position, x))
	{
		iterator after = position;
		++after;
		if (after == end() || comp()(x, *after))
		{
			node* p1 = __iterator2pointer(position);
			node* p2 = __iterator2pointer(after);
			if (p1->right_ == 0)
				return __pointer2iterator(insert_node_at(p1, false, false, x));
			return __pointer2iterator(insert_node_at(p2, true, false, x));
		}
	}
	else // x == *position  hh 000506
		return position;
	return insert_one(x).first;
}

template <class T, class Compare, class Allocator>
typename __tree<T, Compare, Allocator>::iterator
__tree<T, Compare, Allocator>::insert_multi(iterator position, const value_type& x)
{
	node* p1;
	node* p2;
	bool first_node = false;
	if (position == end() || !comp()(*position, x))
	{
		iterator before = position;
		if (before != begin() && comp()(x, *--before))
		{
			before = position = upper_bound(x);
			if (before != begin())
				--before;
		}
		p1 = __iterator2pointer(before);
		p2 = __iterator2pointer(position);
		first_node = position == begin();
	}
	else // position != end && x > *position && !empty()
	{
		iterator after = position;
		++after;
		if (after != end() && comp()(*after, x))
		{
			after = position = lower_bound(x);
			--position;
		}
		p1 = __iterator2pointer(position);
		p2 = __iterator2pointer(after);
	}
	if (p2->left_ == 0)
		return __pointer2iterator(insert_node_at(p2, true, first_node, x));
	return __pointer2iterator(insert_node_at(p1, false, false, x));
}

#ifndef _MSL_NO_MEMBER_TEMPLATE
	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE

		template <class T, class Compare, class Allocator>
		template <class InputIterator>
		inline
		void
		__tree<T, Compare, Allocator>::insert_one(InputIterator first, InputIterator last)
		{
			for (; first != last; ++first)
				insert_one(end(), *first);
		}

		template <class T, class Compare, class Allocator>
		template <class InputIterator>
		inline
		void
		__tree<T, Compare, Allocator>::insert_multi(InputIterator first, InputIterator last)
		{
			for (; first != last; ++first)
				insert_multi(end(), *first);
		}

	#endif
#else

	template <class T, class Compare, class Allocator>
	inline
	void
	__tree<T, Compare, Allocator>::insert_one(const_iterator first, const_iterator last)
	{
		for (; first != last; ++first)
			insert_one(end(), *first);
	}

	template <class T, class Compare, class Allocator>
	inline
	void
	__tree<T, Compare, Allocator>::insert_one(const value_type* first, const value_type* last)
	{
		for (; first != last; ++first)
			insert_one(end(), *first);
	}

	template <class T, class Compare, class Allocator>
	inline
	void
	__tree<T, Compare, Allocator>::insert_multi(const_iterator first, const_iterator last)
	{
		for (; first != last; ++first)
			insert_multi(end(), *first);
	}

	template <class T, class Compare, class Allocator>
	inline
	void
	__tree<T, Compare, Allocator>::insert_multi(const value_type* first, const value_type* last)
	{
		for (; first != last; ++first)
			insert_multi(end(), *first);
	}

#endif

template <class T, class Compare, class Allocator>
typename __tree<T, Compare, Allocator>::node*
__tree<T, Compare, Allocator>::insert_node_at(node* p, bool leftchild, bool is_leftmost,
	const value_type& x)
{
	if (size() > max_size() - 1)
		#ifndef _MSL_NO_EXCEPTIONS
			throw length_error("tree::insert length error");
		#else
			__msl_error("tree::insert length error\n");
		#endif
	node* n = node_alloc().allocate(1);
	#ifndef _MSL_NO_EXCEPTIONS
	try
	{
	#endif
		alloc().construct(&n->data_, x);
	#ifndef _MSL_NO_EXCEPTIONS
	}
	catch (...)
	{
		node_alloc().deallocate(n, 1);
		throw;
	}
	#endif
	n->left_ = n->right_ = 0;
	n->parent_ = p;
	if (leftchild)
		p->left_ = n;
	else
		p->right_ = n;
	++sz();
	balance_insert(n, root());
	if (is_leftmost)
		front() = n;
	return n;
}

template <class T, class Compare, class Allocator>
void
__tree<T, Compare, Allocator>::erase(iterator position)
{
	node* z = __iterator2pointer(position);
	if (position == begin())
		front() = __iterator2pointer(++position);
	balance_erase(z, root());
	alloc().destroy(&z->data_);
	node_alloc().deallocate(z, 1);
	--sz();
}

#if !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_MSL_MUST_INLINE_MEMBER_TEMPLATE)

	template <class T, class Compare, class Allocator>
	template <class Key>
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::erase_one(const Key& x)
	{
		iterator i = find(x);
		if (i == end())
			return 0;
		erase(i);
		return 1;
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::erase_multi(const Key& x)
	{
		pair<iterator, iterator> i = equal_range(x);
		size_type result = (size_type)_STD::distance(i.first, i.second);
		erase(i.first, i.second);
		return result;
	}

#else

	template <class T, class Compare, class Allocator>
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::erase_one(const value_type& x)
	{
		iterator i = find(x);
		if (i == end())
			return 0;
		erase(i);
		return 1;
	}

	template <class T, class Compare, class Allocator>
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::erase_multi(const value_type& x)
	{
		pair<iterator, iterator> i = equal_range(x);
		size_type result = (size_type)_STD::distance(i.first, i.second);
		erase(i.first, i.second);
		return result;
	}

#endif

template <class T, class Compare, class Allocator>
inline
void
__tree<T, Compare, Allocator>::erase(iterator first, iterator last)
{
	while (first != last)
		erase(first++);
}

template <class T, class Compare, class Allocator>
void
__tree<T, Compare, Allocator>::swap(__tree& x)
{
	if (this != &x)
	{
		Metrowerks::swap(alloc_, x.alloc_);
		Metrowerks::swap(node_alloc_, x.node_alloc_);
		Metrowerks::swap(comp_, x.comp_);
		if (root() != 0)
			root()->parent_ = (node*)&tail();
		else
			front() = (node*)&tail();  // hh 990720
		if (x.root() != 0)
			x.root()->parent_ = (node*)&x.tail();
		else
			x.front() = (node*)&x.tail();
	#ifdef _MSL_DEBUG
		iterator::swap(this, &x);
		const_iterator::swap(this, &x);
	#endif
	}
}

template <class T, class Compare, class Allocator>
void
__tree<T, Compare, Allocator>::clear()
{
	if (root() != 0)
	{
		destroy(root());
		sz() = 0;
		root() = 0;
		front() = (node*)&tail();
	}
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::value_compare
__tree<T, Compare, Allocator>::value_comp() const
{
	return comp();
}

#if !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_MSL_MUST_INLINE_MEMBER_TEMPLATE)

	template <class T, class Compare, class Allocator>
	template <class Key>
	typename __tree<T, Compare, Allocator>::iterator
	__tree<T, Compare, Allocator>::find(const Key& x)
	{
		node* i = root();
		node* j = (node*)&tail();
		while (i != 0)
		{
			if (!comp()(i->data_, x))
			{
				j = i;
				i = (node*)i->left_;
			}
			else
				i = (node*)i->right_;
		}
		if (j == (node*)&tail() || comp()(x, j->data_))
			return end();
		return __pointer2iterator(j);
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	inline
	typename __tree<T, Compare, Allocator>::const_iterator
	__tree<T, Compare, Allocator>::find(const Key& x) const
	{
		return const_cast<__tree&>(*this).find(x);
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	inline
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::count_one(const Key& x) const
	{
		return size_type(!(find(x) == end()));
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	inline
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::count_multi(const Key& x) const
	{
		pair<const_iterator, const_iterator> i = equal_range(x);
		return (size_type)_STD::distance(i.first, i.second);
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	typename __tree<T, Compare, Allocator>::iterator
	__tree<T, Compare, Allocator>::lower_bound(const Key& x)
	{
		node* i = root();
		node* j = (node*)&tail();
		while (i != 0)
		{
			if (!comp()(i->data_, x))
			{
				j = i;
				i = (node*)i->left_;
			}
			else
				i = (node*)i->right_;
		}
		return __pointer2iterator(j);
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	inline
	typename __tree<T, Compare, Allocator>::const_iterator
	__tree<T, Compare, Allocator>::lower_bound(const Key& x) const
	{
		return const_cast<__tree&>(*this).lower_bound(x);
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	typename __tree<T, Compare, Allocator>::iterator
	__tree<T, Compare, Allocator>::upper_bound(const Key& x)
	{
		node* i = root();
		node* j = (node*)&tail();
		while (i != 0)
		{
			if (comp()(x, i->data_))
			{
				j = i;
				i = (node*)i->left_;
			}
			else
				i = (node*)i->right_;
		}
		return __pointer2iterator(j);
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	inline
	typename __tree<T, Compare, Allocator>::const_iterator
	__tree<T, Compare, Allocator>::upper_bound(const Key& x) const
	{
		return const_cast<__tree&>(*this).upper_bound(x);
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	inline
	pair<typename __tree<T, Compare, Allocator>::const_iterator, typename __tree<T, Compare, Allocator>::const_iterator>
	__tree<T, Compare, Allocator>::equal_range(const Key& x) const
	{
		return make_pair(lower_bound(x), upper_bound(x));
	}

	template <class T, class Compare, class Allocator>
	template <class Key>
	inline
	pair<typename __tree<T, Compare, Allocator>::iterator, typename __tree<T, Compare, Allocator>::iterator>
	__tree<T, Compare, Allocator>::equal_range(const Key& x)
	{
		return make_pair(lower_bound(x), upper_bound(x));
	}

#else

	template <class T, class Compare, class Allocator>
	typename __tree<T, Compare, Allocator>::iterator
	__tree<T, Compare, Allocator>::find(const value_type& x)
	{
		node* i = root();
		node* j = (node*)&tail();
		while (i != 0)
		{
			if (!comp()(i->data_, x))
			{
				j = i;
				i = (node*)i->left_;
			}
			else
				i = (node*)i->right_;
		}
		if (j == (node*)&tail() || comp()(x, j->data_))
			return end();
		return __pointer2iterator(j);
	}

	template <class T, class Compare, class Allocator>
	inline
	typename __tree<T, Compare, Allocator>::const_iterator
	__tree<T, Compare, Allocator>::find(const value_type& x) const
	{
		return const_cast<__tree&>(*this).find(x);
	}

	template <class T, class Compare, class Allocator>
	inline
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::count_one(const value_type& x) const
	{
		return size_type(!(find(x) == end()));
	}

	template <class T, class Compare, class Allocator>
	inline
	typename __tree<T, Compare, Allocator>::size_type
	__tree<T, Compare, Allocator>::count_multi(const value_type& x) const
	{
		pair<const_iterator, const_iterator> i = equal_range(x);
		return (size_type)_STD::distance(i.first, i.second);
	}

	template <class T, class Compare, class Allocator>
	typename __tree<T, Compare, Allocator>::iterator
	__tree<T, Compare, Allocator>::lower_bound(const value_type& x)
	{
		node* i = root();
		node* j = (node*)&tail();
		while (i != 0)
		{
			if (!comp()(i->data_, x))
			{
				j = i;
				i = (node*)i->left_;
			}
			else
				i = (node*)i->right_;
		}
		return __pointer2iterator(j);
	}

	template <class T, class Compare, class Allocator>
	inline
	typename __tree<T, Compare, Allocator>::const_iterator
	__tree<T, Compare, Allocator>::lower_bound(const value_type& x) const
	{
		return const_cast<__tree&>(*this).lower_bound(x);
	}

	template <class T, class Compare, class Allocator>
	typename __tree<T, Compare, Allocator>::iterator
	__tree<T, Compare, Allocator>::upper_bound(const value_type& x)
	{
		node* i = root();
		node* j = (node*)&tail();
		while (i != 0)
		{
			if (comp()(x, i->data_))
			{
				j = i;
				i = (node*)i->left_;
			}
			else
				i = (node*)i->right_;
		}
		return __pointer2iterator(j);
	}

	template <class T, class Compare, class Allocator>
	inline
	typename __tree<T, Compare, Allocator>::const_iterator
	__tree<T, Compare, Allocator>::upper_bound(const value_type& x) const
	{
		return const_cast<__tree&>(*this).upper_bound(x);
	}

	template <class T, class Compare, class Allocator>
	inline
	pair<__tree<T, Compare, Allocator>::const_iterator, __tree<T, Compare, Allocator>::const_iterator>
	__tree<T, Compare, Allocator>::equal_range(const value_type& x) const
	{
		return make_pair(lower_bound(x), upper_bound(x));
	}

	template <class T, class Compare, class Allocator>
	inline
	pair<__tree<T, Compare, Allocator>::iterator, __tree<T, Compare, Allocator>::iterator>
	__tree<T, Compare, Allocator>::equal_range(const value_type& x)
	{
		return make_pair(lower_bound(x), upper_bound(x));
	}

#endif

template <class T, class Compare, class Allocator>
void
__tree<T, Compare, Allocator>::destroy(node* p)
{
	if (p->left_ != 0)
		destroy((node*)(p->left_));
	if (p->right_ != 0)
		destroy((node*)(p->right_));
#ifdef _MSL_DEBUG
	__invalidate_iterator(iterator(__pointer2iterator(p)));
#endif
	alloc().destroy(&p->data_);
	node_alloc().deallocate(p, 1);
}

template <class T, class Compare, class Allocator>
typename __tree<T, Compare, Allocator>::node*
__tree<T, Compare, Allocator>::copy(const node* x)
{
	node* result = node_alloc().allocate(1);
	result->left_ = result->right_ = 0;
	#ifndef _MSL_NO_EXCEPTIONS
	try
	{
	#endif
		if (x->left_ != 0)
		{
			result->left_ = copy((node*)(x->left_));
			result->left_->parent_ = result;
		}
		if (x->right_ != 0)
		{
			result->right_ = copy((node*)(x->right_));
			result->right_->parent_ = result;
		}
		alloc().construct(&result->data_, x->data_);
		result->set_color(x->color());
	#ifndef _MSL_NO_EXCEPTIONS
	}
	catch (...)
	{
		if (result->left_ != 0)
			destroy((node*)(result->left_));
		if (result->right_ != 0)
			destroy((node*)(result->right_));
		node_alloc().deallocate(result, 1);
		throw;
	}
	#endif
	return result;
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::node*&
__tree<T, Compare, Allocator>::root()
{
	return (node*&)tail().left_;
}

template <class T, class Compare, class Allocator>
inline
typename __tree<T, Compare, Allocator>::node*
__tree<T, Compare, Allocator>::root() const
{
	return (node*)tail().left_;
}

template <class T, class Compare, class Allocator>
int
__tree<T, Compare, Allocator>::count_black(node_base* x) const
{
	int cleft  = x->left_  == 0 ? 1 : count_black(x->left_);
	if (cleft < 0)
		return -1;
	int cright = x->right_ == 0 ? 1 : count_black(x->right_);
	if (cright < 0)
		return -1;
	if (cleft != cright)
		return -1;
	if (x->color() == black)
		++cleft;
	return cleft;
}

#ifndef _MSL_NO_CPP_NAMESPACE
	} // namespace std
#endif

#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT
	#pragma enumsalwaysint reset
#endif

#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT
	#pragma bool reset
#endif

#pragma options align=reset

#endif // _TREE

// hh 971220 fixed MOD_INCLUDE
// hh 971226 added alignment wrapper
// hh 980105 changed pointer & reference to const versions in const_iterator base class
// hh 980105 Added qualified name to iterator
// hh 980111 <stdexcept> commented out.  Not needed
// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT
// hh 981130 Rewrote.
// hh 990720 Put debugging code under #ifdef _TREE_DEBUG
// hh 990720 Fixed bug in swap when trees are empty
// hh 990720 Made iterator comparison functions global friends
// hh 990820 Modified insert_one(i, x) and insert_multi(i, x) so that you would get
//           constant time performance if the correct insertion spot is before or after i.
// hh 990820 Optimized methods operating with keys only.
// hh 990820 Optimized operator []
// hh 990826 To reduce dependence on T()
// hh 990924 Added casts in const/iterator increment/decrement operators to comply with
//           stricter compiler.
// hh 991003 Changed find to find the first element in the tree.
// hh 991003 Changed the const versions of find, lower_bound and upper_bound to be implemented
//           in terms of the non-const versions.
// hh 000129 Changed file name from tree.h to tree to avoid conflict with Java file name.
// hh 000506 Eliminated compare from insert_multi and insert_one
// hh 010125 Removed dependence on string
// hh 010301 Protected min and max from macro abuse.
// hh 010402 Removed 68K CMF support
// hh 010404 Substituted compressed_pair for _EmptyMemberOpt
// hh 010507 Implemented "insert closest" in insert_multi
// hh 010821 Put casts back on allocators for 2.3 old_argmatch compatibility
